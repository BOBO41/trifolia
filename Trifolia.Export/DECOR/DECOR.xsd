<!-- 
    
    DECOR schema
    Copyright (C) 2009-2015 Dr. Kai U. Heitmann
    
    This program is free software; you can redistribute it and/or modify it under the terms 
    of the GNU General Public License as published by the Free Software Foundation; 
    either version 3 of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.
    
    See http://www.gnu.org/licenses/gpl.html
    
-->
<xs:schema xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:sqf="http://www.schematron-quickfix.com/validator/process" elementFormDefault="qualified">


    <!-- include DECOR datatype defintions -->
    <xs:include schemaLocation="DECOR-datatypes.xsd"/>

    <!-- this is the root element of any decor main file -->
    <xs:element name="decor">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Unique Ids</sch:title>
                    <sch:rule context="
                        project | 
                        project/author | 
                        datasets/dataset |
                        datasets/dataset//concept[not(ancestor::history)][not(parent::conceptList)][@id] |
                        scenarios/actors/actor | 
                        scenarios/scenario | 
                        scenarios/scenario//transaction | 
                        terminology/valueSet[@id] | 
                        rules/template[@id] | 
                        issues/issue">
                        <sch:let name="currentId" value="@id"/>
                        <sch:let name="currentEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="allCurrentIdEffectiveDates" value="
                            /decor/project[@id=$currentId] | 
                            /decor/project/author[@id=$currentId] | 
                            /decor/datasets/dataset[@id=$currentId and @effectiveDate=$currentEffectiveDate] |
                            /decor/datasets/dataset//concept[@id=$currentId and @effectiveDate=$currentEffectiveDate][not(ancestor::history)][not(parent::conceptList)] |
                            /decor/scenarios/actors/actor[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/scenarios/scenario[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/scenarios/scenario//transaction[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/terminology/valueSet[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/rules/template[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/issues/issue[@id=$currentId]"/>
                        <sch:let name="allCurrentIds" value="
                            /decor/project[@id=$currentId] | 
                            /decor/project/author[@id=$currentId] | 
                            /decor/datasets/dataset[@id=$currentId] | 
                            /decor/datasets/dataset//concept[@id=$currentId][not(ancestor::history)][not(parent::conceptList)] |
                            /decor/scenarios/actors/actor[@id=$currentId] | 
                            /decor/scenarios/scenario[@id=$currentId] | 
                            /decor/scenarios/scenario//transaction[@id=$currentId] | 
                            /decor/terminology/valueSet[@id=$currentId] | 
                            /decor/rules/template[@id=$currentId] | 
                            /decor/issues/issue[@id=$currentId]"/>
                        <sch:assert test="if (@effectiveDate) then (count($allCurrentIdEffectiveDates)=1) else (count($allCurrentIds)=1)">ERROR: The <sch:name/>/@id '<sch:value-of select="$currentId"/>' SHALL be unique.</sch:assert>
                    </sch:rule>
                </sch:pattern>
                <!-- transaction label is used for created of Schematron name. If there are duplicates, e.g. label="Acknowledgement", then this will cause Schematron generation to fail -->
                <sch:pattern>
                    <sch:title>Validate Unique Label</sch:title>
                    <sch:let name="allLabels" value="//scenario//transaction/@label"/>
                    <sch:rule context="scenario//transaction[@label]">
                        <sch:let name="scenarioStatus" value="ancestor::scenario/@statusCode"/>
                        <sch:let name="currentLabel" value="@label"/>
                        <sch:assert role="error" test="not($scenarioStatus=('new','draft','pending')) or count($allLabels[.=$currentLabel])=1"
                            >ERROR: <sch:name/>/@label '<sch:value-of select="$currentLabel"/>' within a '<sch:value-of select="$scenarioStatus"/>' scenario MUST be unique in this DECOR file</sch:assert>
                        <sch:assert role="warning" test="$scenarioStatus=('new','draft','pending') or count($allLabels[.=$currentLabel])=1"
                            >WARNING: <sch:name/>/@label '<sch:value-of select="$currentLabel"/>' within a '<sch:value-of select="$scenarioStatus"/>' scenario SHOULD be unique in this DECOR file</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="1" maxOccurs="1" ref="project">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Projectinformatie</xforms:label>
                            <xforms:label xml:lang="en-US">Project Information</xforms:label>
                            <xforms:label xml:lang="de-DE">Informationen zum Projekt</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Projectinformatie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Project Information</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Informationen zum Projekt</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="1" ref="datasets">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Datasetdefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Data Set Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Data Set Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Data Set Definitie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Data Set Definition</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Data Set Definition</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="1" ref="scenarios">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Scenariodefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Scenario Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Scenario Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Scenariodefinitie, inclusief actoren, transacties, modellen, cardinaliteiten en conformancestatements</xs:documentation>
                        <xs:documentation xml:lang="en-US">Scenario Definition, with actors, transactions, models, cardinalities, conformance statements</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Scenario Definition, mit Aktoren, Transaktionen, Modellem, Kardinalitäten, Konformitätsangaben</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- identifiers -->
                <xs:element minOccurs="0" maxOccurs="1" ref="ids">
                    <xs:annotation>
                        <xs:appinfo>
                            <sch:pattern>
                                <sch:title>Validate Ids</sch:title>
                                <sch:let name="allTypes" value="tokenize('DS,DE,SC,TR,CS,IS,AC,CL,EL,TM,VS,RL,TX,SX,EX,QX,CM',',')"/>
                                <sch:let name="allExtensions" value="tokenize('1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,20,21',',')"/>
                                
                                <sch:let name="allTypesCount" value="count($allTypes)"/>
                                <sch:rule context="ids">
                                    <sch:let name="idsBaseIdTypes" value="count(distinct-values(baseId/@type))"/>
                                    <sch:let name="idsDefaultBaseIdTypes" value="count(distinct-values(defaultBaseId/@type))"/>
                                    <sch:let name="idsBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(baseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:let name="idsDefaultBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(defaultBaseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:assert role="warning" test="$idsBaseIdTypes&gt;=$allTypesCount" sqf:fix="addMissingBaseIds"
                                        >WARNING: you did not define a baseId for every possible type. This might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsBaseIdTypes"/>'. Missing '<sch:value-of select="$idsBaseIdTypesMissing"/>'.</sch:assert>
                                    <sch:assert role="warning" test="$idsDefaultBaseIdTypes&gt;=$allTypesCount" sqf:fix="addMissingDefaultBaseIds"
                                        >WARNING: you did not define a defaultBaseId for every possible type. This might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsDefaultBaseIdTypes"/>'. Missing '<sch:value-of select="$idsDefaultBaseIdTypesMissing"/>'.</sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </xs:appinfo>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Gebruikte identificaties</xforms:label>
                            <xforms:label xml:lang="en-US">Identifiers used</xforms:label>
                            <xforms:label xml:lang="de-DE">Genutzte Identifikatoren</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Gebruikte identificaties, bedoeld voor weergavedoeleinden</xs:documentation>
                        <xs:documentation xml:lang="en-US">Identifiers used, rendering only</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Genutzte Identifikatoren, nur zur Anzeige</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- terminology, e.g. value sets -->
                <xs:element minOccurs="0" maxOccurs="1" ref="terminology">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Terminologische definities</xforms:label>
                            <xforms:label xml:lang="en-US">Terminology definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Terminologische Definitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Terminologische definities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Terminology definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Terminologische Definitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- rules -->
                <xs:element minOccurs="0" maxOccurs="1" ref="rules">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Regeldefinities</xforms:label>
                            <xforms:label xml:lang="en-US">Rules definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Regeldefinitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Regeldefinities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Rules definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Regeldefinitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- issues -->
                <xs:element minOccurs="0" maxOccurs="1" ref="issues">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Issuelijst</xforms:label>
                            <xforms:label xml:lang="en-US">Issue list</xforms:label>
                            <xforms:label xml:lang="de-DE">Problemliste</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Issuelijst</xs:documentation>
                        <xs:documentation xml:lang="en-US">Issue list</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Problemliste</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="repository" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is een (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is a (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist ein (Building Block) Repository (BBR)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is a (building block) repository (BBR)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="private" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is privé</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is private</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist privat</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is private, i.e. should NOT be included in searches from external.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="release" type="SmallNonNegativeInteger" fixed="1000" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project release nummer</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project release number</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt Release Nummer</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release number (dddd) of the DECOR project file, for conversion detection beteeen releases later</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="DecorCompilationAttributes"/>
            
            <xs:anyAttribute namespace="##other" processContents="skip">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Contains dummy attributes that force xmlns declarations for templates</xs:documentation>
                </xs:annotation>
            </xs:anyAttribute>
        </xs:complexType>
    </xs:element>
    
    <!-- 
    
        project
        
    -->
    <xs:element name="project">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="copyright" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="reference" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="restURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultElementNamespace" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="contact" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="buildingBlockRepository" minOccurs="0" maxOccurs="unbounded"/>
                <xs:choice maxOccurs="unbounded">
                    <xs:element name="version" type="ProjectHistory" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="release" type="ProjectRelease" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="defaultLanguage" type="xs:language" use="required"/>
            <xs:attribute name="experimental" type="xs:boolean" default="false" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">experimental</xforms:label>
                        <xforms:label xml:lang="nl-NL">voor testdoeleinden</xforms:label>
                        <xforms:label xml:lang="de-DE">für Testzwecke</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">DECOR project is for testing purposes, not real usage</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="author">
        <xs:complexType mixed="true">
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">author's id, can be a shorthand id per project, e.g. "1"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="username" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">username, must be the same as the corresponding Exist-DB login name</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="email" type="EmailType" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">User's email address</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify this author about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="copyright">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Copyright</sch:title>
                        <sch:rule context="copyright">
                            <sch:assert test="string-length(@years)&gt;0">ERROR: At least one year SHALL be present in copyright.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="years" type="YearRanges" use="required"/>
            <xs:attribute name="by" type="ShortDescriptiveName"/>
            <xs:attribute name="logo" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="addrLine">
        <xs:complexType mixed="true">
            <xs:sequence/>
            <xs:attribute name="type" type="AddressLineType" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="reference">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Reference</sch:title>
                        <sch:rule context="//project/reference">
                            <sch:assert test="substring(@url, string-length(@url), 1)='/'">ERROR: reference URL SHALL end with "/".</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="url" type="Uri"/>
            <xs:attribute name="logo" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="restURI">
        <xs:complexType mixed="true">
            <xs:attribute name="for" type="DecorObjectType" use="required"/>
            <xs:attribute name="format" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultElementNamespace">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Standaard template-element namespace</xforms:label>
                <xforms:label xml:lang="en-US">Default Template Element Namespace</xforms:label>
                <xforms:label xml:lang="de-DE">Default Template Element Namespace</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">The default namespace prefix for all template element name definitions</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="ns" type="NamespacePrefix" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="buildingBlockRepository">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate buildingBlockRepository</sch:title>
                    <sch:rule context="//project/buildingBlockRepository">
                        <sch:assert test="substring(@url, string-length(@url), 1)='/'" sqf:fix="addSlashToURL">ERROR: repository URL SHALL end with "/".</sch:assert>
                        <sch:assert test="substring(@ident, string-length(@ident), 1)='-'" sqf:fix="addHyphenToIdent">ERROR: repository ident SHALL end with "-".</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Repository referentie</xforms:label>
                <xforms:label xml:lang="en-US">Repository reference</xforms:label>
                <xforms:label xml:lang="de-DE">Repository Referenz</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">ART-DECOR repository reference</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="url" type="Uri" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository URI directly pointing to the services, e.g. "http://art-decor.org/services/"; ends with "/"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ident" type="NonEmptyString" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository identification string (prefix), e.g. "ad1bbr-"; ends with "-"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="licenseKey" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">For future use</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="format" type="NonEmptyString" use="optional" default="decor">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">For future use</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    
    <!-- http://www.w3.org/TR/REC-xml/#NT-Name - didn't know how to code hex chars in pattern or I would have -->
    <xs:simpleType name="NamespacePrefix">
        <xs:restriction base="xs:string">
            <xs:pattern value="[^\s:\.0-9-][^\s:]*:"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="contact">
        <xs:complexType>
            <xs:attribute name="email" type="EmailType"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecorObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Decor Object Types. Note: should you ever change list, please also see schematron check with name="Validate Ids".</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">Dataset</xs:documentation>
                    <xs:documentation xml:lang="en-US">Data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">data element</xs:documentation>
                    <xs:documentation xml:lang="en-US">data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">transactie</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">transaction</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="AC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actoren</xforms:label>
                        <xforms:label xml:lang="en-US">Actors</xforms:label>
                        <xforms:label xml:lang="d-DE">Akteure</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">actoren</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">actors</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Aktoren</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">waardelijst</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Problem/Frage</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Regel</xforms:label>
                        <xforms:label xml:lang="en-US">Rule</xforms:label>
                        <xforms:label xml:lang="de-DE">Regel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">regel (intern)</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">rule (internal)</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Regel (intern)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conceptenlijst</xforms:label>
                        <xforms:label xml:lang="en-US">Concept list</xforms:label>
                        <xforms:label xml:lang="de-DE">Konzeptliste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">conceptenlijst</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">concept list</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Konzeptliste</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template-element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testscenario</xforms:label>
                        <xforms:label xml:lang="en-US">Test Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">testscenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testszenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Test dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Test Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Test Data Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">test dataelement</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testdaten-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voorbeeldtransactie</xforms:label>
                        <xforms:label xml:lang="en-US">Example transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Beispiel-Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Example transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Voorbeeldtransactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Beispiel-Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="QX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testeisen</xforms:label>
                        <xforms:label xml:lang="en-US">Test requirements</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Forderung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Test profile</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Test requirements</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Test-Forderung</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Community</xforms:label>
                        <xforms:label xml:lang="en-US">Community</xforms:label>
                        <xforms:label xml:lang="de-DE">Community</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Community. Verwachting is dat het DECOR-project id's toekent aan communities en dat zij verder vertakken onder deze basis</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="ID">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier association</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Identificatiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Identifier association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TA">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terminologiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Terminology association</xforms:label>
                        <xforms:label xml:lang="de-DE">Terminology association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Terminologiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Terminology association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ProjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
    </xs:complexType>
    <xs:complexType name="ProjectRelease">
        <xs:sequence>
            <xs:element name="note" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A human readable release note for convenient human rendition; not used by an application.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
        <xs:attribute name="versionLabel" type="ShortDescriptiveName">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional"/>
    </xs:complexType>
    <xs:simpleType name="ReleaseStatusCodeLifeCycle">
        <!-- 
            release status codes
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Life cycle of the Status Code of a Release</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release under development (nascent). Entered primarily to encourage other users to be aware of ongoing process.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="pending">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Onder revisie vóór de publicatie</xforms:label>
                        <xforms:label xml:lang="en-US">Under pre-publication review</xforms:label>
                        <xforms:label xml:lang="de-DE">Unter Revision vor der Publikation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release is in pre-publication review: the Release is complete, pending appropriate review.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="active">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actief</xforms:label>
                        <xforms:label xml:lang="en-US">Active</xforms:label>
                        <xforms:label xml:lang="de-DE">Aktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release has been published by the governance group (custodian organization) and deemed fit for use. May have associated adoption and annotation metadata.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="retired">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Obsoleet</xforms:label>
                        <xforms:label xml:lang="en-US">Retired</xforms:label>
                        <xforms:label xml:lang="de-DE">Obsolet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release retired: No longer fit for use. Information available for historical reference.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release was never published as active and is withdrawn.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="datasets">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="dataset" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="dataset">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Data Concept</sch:title>
                    <sch:rule context="dataset//concept[@id][not(ancestor::history|parent::conceptList)]">
                        <sch:let name="did" value="(ancestor-or-self::dataset/@id)[last()]"/>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="cef" value="@effectiveDate"/>
                        <sch:assert test="count(ancestor-or-self::dataset//concept[@id=$cid][@effectiveDate=$cef][not(ancestor::history)])=1">ERROR: A concept within
                            a dataset SHALL be unique with respect to its @id and @effectiveTime (id: <sch:value-of select="$cid"/>)</sch:assert>
                        <!--<sch:report role="warning" test="1=1">XXXXX: (<sch:value-of select="$did"/>)(<sch:value-of select="$cid"/>)</sch:report>-->
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">Data Set Properties</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="relationship" type="ObjectRelationships" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="concept" type="DataSetConcept" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="DatasetCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="ObjectRelationships">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The relationships of the current object to another object. Objects MAY have one or more relationships. Each relationship SHALL point to an object of the same nature. Examples include: datasets can relate to datasets, concepts can relate to concepts, value sets can relate to value sets. Note that relationships are implicit, and unchecked. They are a hint to the reader.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="RelationshipTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the relationship, at this point in time something like "SPEC", "GEN", "EQUIV", "VERSION", etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="BasicIdOrOid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the objects id or name. Note that while reference by name is supported, it is also discouraged and should only be used when the object is not a DECOR object, but still needs referencing.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the objects @effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="ArbitraryPropertyType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Adds an arbitrary property as name/value pair to its parent. This property SHALL NOT signify/trigger any specific ART-DECOR behavior. This is useful for storing specific information that has no other obvious place and needs to be in a computable place. Examples include external ids, keywords, review status etc. These properties are not meant to be displayed in all contexts, but only in user defined reports/overviews. The 'value' is mixed XHTML compatible content</xs:documentation>
        </xs:annotation>
        <xs:complexContent mixed="true">
            <xs:extension base="VariousMixedContent">
                <xs:attribute name="name" type="NonEmptyString" use="optional">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">Name of the property.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="DataSetConceptValue">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="property" type="DataSetValueProperty" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="conceptList" type="DataSetConceptList" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                            <sch:title>Validate Data Concept List</sch:title>
                            <sch:rule context="dataset//valueDomain/conceptList[not(ancestor::history)]">
                                <sch:let name="cid" value="@id"/>
                                <sch:let name="cref" value="@ref"/>
                                <!-- In compiled projects, there may legally be multiple instances of the same conceptList -->
                                <sch:assert role="error" test="not(@id) or ancestor::decor[@versionDate] or count(ancestor::datasets//valueDomain/conceptList[@id=$cid][not(ancestor::history)])=1">ERROR: The concept list id '<sch:value-of select="$cid"/>' SHALL be unique within the project</sch:assert>
                                <sch:assert role="error" test="not(@ref) or ancestor::datasets//valueDomain/conceptList[@id=$cref][not(ancestor::history)]">ERROR: The concept list ref '<sch:value-of select="$cref"/>' SHALL have a corresponding conceptList element in the same project</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
                <xs:unique name="conceptlistuniquekey">
                    <xs:selector xpath=".//concept"/>
                    <xs:field xpath="@id"/>
                </xs:unique>
            </xs:element>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
        <xs:attribute name="type" type="DataSetValueType" use="required"/>
    </xs:complexType>
    <xs:complexType name="DataSetValueProperty">
        <xs:attribute name="unit" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Eenheid</xforms:label>
                    <xforms:label xml:lang="en-US">Unit</xforms:label>
                    <xforms:label xml:lang="de-DE">Einheit</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="currency" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Valuta</xforms:label>
                    <xforms:label xml:lang="en-US">Currency</xforms:label>
                    <xforms:label xml:lang="de-DE">Währung</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for monetary quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimum</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range min include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximum</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range max include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fractionDigits" type="FractionDigitsType">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Decimalen</xforms:label>
                    <xforms:label xml:lang="en-US">Digits</xforms:label>
                    <xforms:label xml:lang="de-DE">Ziffern</xforms:label>
                </xs:appinfo>
                <xs:documentation>fraction digits for quantities, e.g. "1" for at least 1 or "1!" for exactly 1</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeStampPrecision" type="DataSetTimeStampPrecision">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Tijdstempelprecisie</xforms:label>
                    <xforms:label xml:lang="en-US">Timestamp precision</xforms:label>
                    <xforms:label xml:lang="de-DE">Genauigkeit Zeitangabe</xforms:label>
                </xs:appinfo>
                <xs:documentation>precisions for timing specs</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Standard</xforms:label>
                    <xforms:label xml:lang="en-US">Default</xforms:label>
                    <xforms:label xml:lang="de-DE">Standard</xforms:label>
                </xs:appinfo>
                <xs:documentation>default value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fixed" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Vast</xforms:label>
                    <xforms:label xml:lang="en-US">Fixed</xforms:label>
                    <xforms:label xml:lang="de-DE">Fest</xforms:label>
                </xs:appinfo>
                <xs:documentation>fixed value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>min length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>max length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetTimeStampPrecision">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Y">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Y!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ) und Monat (MM)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMDHM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ), uur (uu) en minuut (mm)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ), Stunde (ss) und Minute (mm)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DataSetValueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Type for the Value Domain</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="count">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Aantal</xforms:label>
                        <xforms:label xml:lang="en-US">Count</xforms:label>
                        <xforms:label xml:lang="de-DE">Count</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Countable (non-monetary) quantities. Used for countable types such as pregnancies, steps (taken by a physiotherapy patient), number of cigarettes
                        smoked in a day.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="code">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Code</xforms:label>
                        <xforms:label xml:lang="en-US">Code</xforms:label>
                        <xforms:label xml:lang="de-DE">Kode</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A system of valid symbols that substitute for specified concepts e.g. alpha, numeric, symbols and/or combinations, usually defined by a formal
                        reference to a terminology or ontology, but may also be defined by the provision of text.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ordinal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ordinaal</xforms:label>
                        <xforms:label xml:lang="en-US">Ordinal</xforms:label>
                        <xforms:label xml:lang="de-DE">Ordinal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Models rankings and scores, e.g. pain, Apgar, reflex, ASA, Tanner values, etc, where there is a) implied ordering, b) no implication that the
                        distance between each value is con- stant, and c) the total number of values is finite. Note that although the term ‘ordinal’ in mathematics means natural numbers only, here
                        any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="identifier">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatie</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number,
                        prescription id, order id, and so on.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="string">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">String</xforms:label>
                        <xforms:label xml:lang="en-US">String</xforms:label>
                        <xforms:label xml:lang="de-DE">String</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Plain text without markup</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="text">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tekst</xforms:label>
                        <xforms:label xml:lang="en-US">Text</xforms:label>
                        <xforms:label xml:lang="de-DE">Text</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc. Visual formatting and hyperlinks may be
                        included.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="date">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum</xforms:label>
                        <xforms:label xml:lang="en-US">Date</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used
                        for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datetime">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum+tijd</xforms:label>
                        <xforms:label xml:lang="en-US">Date+time</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum+Zeit</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601. Used for recording a precise point in real world
                        time, e.g. the exact date and time of the birth of a baby, and for approximate time stamps, e.g. the origin of an history observation which is only partially
                        known.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="complex">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Samengestelde gegevens</xforms:label>
                        <xforms:label xml:lang="en-US">Collection of data</xforms:label>
                        <xforms:label xml:lang="de-DE">Zusammenstellung von Daten</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">collection of data, e.g. complex specification as part of dosage instructions, a person's name (if not further specified)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="quantity">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoeveelheid</xforms:label>
                        <xforms:label xml:lang="en-US">Quantity</xforms:label>
                        <xforms:label xml:lang="de-DE">Anzahl</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Quantitified type representing "scientific" quantities, i.e. quantities expressed as a magnitude and units. For time durations duration shall be
                        used; for monetary amounts currency shall be used (not yet available, currently use 'quantity')</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="duration">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tijdsduur</xforms:label>
                        <xforms:label xml:lang="en-US">Duration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zeitraum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Is a quantity, represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the
                        duration is “backwards” in time rather than forwards.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="boolean">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Boolean</xforms:label>
                        <xforms:label xml:lang="en-US">Boolean</xforms:label>
                        <xforms:label xml:lang="de-DE">Boolean</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Items which are truly boolean data, such as true/false or yes/no answers.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="blob">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Binair</xforms:label>
                        <xforms:label xml:lang="en-US">Binary</xforms:label>
                        <xforms:label xml:lang="de-DE">Binary</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Things that are typically stored as binary objects in the computer world and need to be rendered appropriately, e.g. images: like X-rays,
                        computertomographic images and scans.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="decimal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Decimaal getal</xforms:label>
                        <xforms:label xml:lang="en-US">Decimal number</xforms:label>
                        <xforms:label xml:lang="de-DE">Dezimalzahl</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Decimal number (rarely used, in most cases a decimal number is actually a quantity).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConcept">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept, is either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A group may contain other groups or items and does not contain a operationalizations or value domain definitions</xs:documentation>
            <xs:documentation xml:lang="en-US">An item typically has operationalizations and value domain definitions and may not contain a concept</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Data Concept</sch:title>
                    <sch:rule context="dataset[@statusCode=('new','draft')]//concept[@statusCode=('new','draft')][not(ancestor::history)][not(parent::conceptList)]">
                        <!-- In compiled projects, concepts will be expanded and include info from the original -->
                        
                        <sch:assert test="(@id and @effectiveDate) or (@ref and @flexibility)">ERROR: <sch:name/> SHALL have @id with @effectiveDate, or @ref with @flexibility</sch:assert>
                        <sch:assert test="not(@id and (@ref|@flexibility)) or ancestor::decor[@versionDate]">ERROR: <sch:name/>/@id='<sch:value-of select="@id"/>' SHALL NOT co-occur with @ref or @flexibility</sch:assert>
                        <sch:assert test="not(@ref and *) or ancestor::decor[@versionDate]">ERROR: <sch:name/>/@ref='<sch:value-of select="@ref"/>' SHALL NOT be a reference and have child elements</sch:assert>
                        <sch:assert test="not(@ref and (@* except (@ref|@flexibility))) or ancestor::decor[@versionDate]">ERROR: <sch:name/>/@ref='<sch:value-of select="@ref"/>' SHALL NOT be a reference and have attributes other than @flexibility</sch:assert>

                        <!-- if not inherit/@ref then @type and @statusCode SHALL be present -->
                        <sch:assert test="@type or (inherit|@ref)">ERROR: <sch:name/>/@type SHALL be present if not inherited or referenced.</sch:assert>
                        <sch:assert test="@statusCode or @ref">ERROR: <sch:name/>/@statusCode SHALL be present if not referenced.</sch:assert>
                        
                        <!-- if inherit/@ref then @type is prohibited -->
                        <sch:assert test="not(@type and (inherit|@ref)) or ancestor::decor[@versionDate]">ERROR: If concept inherits or is a reference then @type SHALL NOT be present.</sch:assert>
                        
                        <!-- if inherit/@ref then @effectiveDate is required -->
                        <sch:assert test="not(inherit) or (inherit[@ref][@effectiveDate])">ERROR: If concept has a inherit/@ref then @effectiveDate SHALL be present.</sch:assert>

                        <!-- if not inherit then name and desc SHALL be present-->
                        <sch:assert test="inherit|@ref or (name and desc)">ERROR: If concept has an @id then name and desc SHALL be present.</sch:assert>

                        <!-- if inherit/@ref then child elements except comment or concept or rationale SHALL NOT be present -->
                        <sch:assert test="not(inherit/@ref) or count(* except (comment|concept|rationale|inherit|history))=0 or ancestor::decor[@versionDate]">ERROR: If concept has a inherit/@ref, child elements except comment, concept, history or rationale SHALL NOT be present.</sch:assert>

                        <!--
                        <sch:assert test="string-length(name)>1">ERROR: concept/name SHALL be a short string.</sch:assert>
                        <sch:assert test="string-length(desc)>1">ERROR: concept/name SHALL be a short string.</sch:assert>
                        -->
                        <sch:let name="inhcid" value="inherit/@ref"/>
                        <sch:let name="inhced" value="inherit/@effectiveDate"/>
                        <sch:let name="inhc" value="//dataset//concept[@id=$inhcid][@effectiveDate=$inhced][not(ancestor::history|parent::conceptList)]"/>
                        <sch:let name="inhctype" value="$inhc/@type"/>
                        <sch:let name="ctype" value="if (.[@type]) then (@type) else if (count($inhctype)=1 and $inhc/concept and string-length($inhctype)&gt;0) then ($inhctype) else ('')"/>
                        <sch:assert role="error" test="($ctype='group' and count(concept)&gt;0 and count(valueDomain)=0) or not($ctype='group')">ERROR: A concept of (inherited) type group SHOULD have concept child definition(s).</sch:assert>
                        <sch:assert role="error" test="($ctype='item' and count(concept)=0) or not($ctype='item')">ERROR: A concept of (inherited) type item SHOULD NOT have concept child definition(s).</sch:assert>
                        <sch:assert role="error" test="not(string-join($inhctype,'')='item' and count(valueDomain)&gt;0) or ancestor::decor[@versionDate]">ERROR: A concept of inherited type item SHOULD NOT have a value domain definition.</sch:assert>
                        <sch:report role="warning" test="@type='item' and count(valueDomain[@type])=0 and count(inherit)=0">WARNING: A concept of type item SHOULD have a value domain with a type definition.</sch:report>
                        <sch:assert test="count($inhctype) &lt;= 1">ERROR: Concept id <sch:value-of select="@id"/> and effective date <sch:value-of select="@effectiveDate"/> has ambiguous inheritance as the concept it inherits from is a duplicate.</sch:assert>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="ced" value="@effectiveDate"/>
                        <sch:let name="cnm" value="if (inherit[@ref]) then ($inhc/name/text())[1] else (name[1]/text())"/>
                        <sch:let name="isInTransaction" value="//representingTemplate[@ref]/concept[@ref=$cid][ancestor::transaction/@statusCode=('draft','final')][ancestor::scenario/@statusCode=('draft','final')]"/>
                        <sch:let name="isInTemplate" value="//rules/templateAssociation/concept[@ref=$cid][not(@effectiveDate) or @effectiveDate=$ced]"/>
                        <sch:let name="rulesDefined" value="//rules[template]"/>
                        <sch:assert role="warning" test="not($isInTransaction) or $isInTemplate or not($rulesDefined)">WARNING: concept <sch:value-of select="$ctype"/> with conceptId '<sch:value-of select="$cid"/>' ('<sch:value-of select="$cnm"/>') is used in at least one transaction, but does not have a templateAssociation</sch:assert>
                        
                        <sch:let name="inhconcept" value="(//datasets/dataset//concept[@id=$inhcid][string-length($inhced)>0 or @effectiveDate=$inhced][not(ancestor-or-self::history|parent::conceptList)])[1]"/>
                        <sch:assert role="error" test="not(inherit) or not($inhconcept/inherit)" sqf:fix="replaceInheritWithIdOfOriginalConcept"
                            >ERROR: A concept SHALL NOT inherit from a concept that inherits. It MUST inherit from the original concept ref="<sch:value-of select="$inhconcept/inherit/@ref"/>" effectiveDate="<sch:value-of select="$inhconcept/inherit/@effectiveDate"/>"</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationImplementation"/>
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept inherits properties from another concept</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Name (short). One name per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Description (long). One to many descriptions per language</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="source" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Source, human readable hint where this data element originally comes from</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="rationale" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set rationale, human readable justification or explanation why this concept is present</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="comment" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept comments</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept properties</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="relationship" type="ObjectRelationships" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept relationship to another data set concept.</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- following elements for type item only -->
            <xs:element name="operationalization" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Operationalization, e.g. how to measure, obtain, specify the value of an observation</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="valueDomain" type="DataSetConceptValue" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Value Domain, properties of the value in an instance</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationValueSet"/>
            <!-- Only relevant after compilation -->
            <xs:group ref="DatasetConceptCompilationTerminologyAssociation"/>
            
            <!-- following elements for type group only -->
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>

            <!-- history -->
            <xs:element name="history" type="DataSetConceptHistory" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept History</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <!--
            attributes checked by schematrons, see above
        -->
        <xs:attribute name="id" type="Oid" use="optional"/>
        <xs:attribute name="ref" type="Oid" use="prohibited">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Attributes @ref and @flexibility are reserved for potential future use, but remain unsupported until the full scope is determined</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="TimeStampNoTimezone" use="prohibited">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Attributes @ref and @flexibility are reserved for potential future use, but remain unsupported until the full scope is determined</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Prohibited when concept is a reference. Required in all other cases.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="DataSetConceptType" use="optional"/>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="DatasetConceptCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="DataSetConceptHistory">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept History of either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A Concept History may not contain nested history items</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="validTimeHigh" use="required" type="TimeStampNoTimezone">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The time that the given information ceased to be correct.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetConceptType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">group of data set items</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">groep van data set items</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Gruppe von Dataset-Items</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="item">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Item</xforms:label>
                        <xforms:label xml:lang="en-US">Item</xforms:label>
                        <xforms:label xml:lang="de-DE">Item</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">data set item</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">datasetitem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Dataset-Item</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ProcessCode">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of processing</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="strict">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Strikt</xforms:label>
                        <xforms:label xml:lang="en-US">Strict</xforms:label>
                        <xforms:label xml:lang="de-DE">Strikt</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="lax">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Los</xforms:label>
                        <xforms:label xml:lang="en-US">Lax</xforms:label>
                        <xforms:label xml:lang="de-DE">Locker</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ItemStatusCodeLifeCycle">
        <!-- 
            o - > new- - > draft - - > final - - - > o
             \
              \  - - - > rejected
               \ - - - > cancelled
                \ - - -> deprecated
                
            
               
            (approved) and (implemented) are under approvals
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Life cycle of the Status Code of a Data Set Item</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="new">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Nieuw</xforms:label>
                        <xforms:label xml:lang="en-US">New</xforms:label>
                        <xforms:label xml:lang="de-DE">Neu</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item just created and is new and work in progress to become a draft/finalized item/issue. Beyond the author, nobody should look at this
                        item/issue unless it's status code is draft or finalized.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item is draft</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="pending">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Onder revisie vóór de publicatie</xforms:label>
                        <xforms:label xml:lang="en-US">Under pre-publication review</xforms:label>
                        <xforms:label xml:lang="de-DE">Unter Revision vor der Publikation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item is in pre-publication review: the item is complete, pending appropriate review.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="final">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Definitief</xforms:label>
                        <xforms:label xml:lang="en-US">Final</xforms:label>
                        <xforms:label xml:lang="de-DE">Definitiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item finalized, ready for approval</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item is rejected</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item is cancelled</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="deprecated">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verouderd</xforms:label>
                        <xforms:label xml:lang="en-US">Deprecated</xforms:label>
                        <xforms:label xml:lang="de-DE">Veraltet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Item is deprecated, i.e. item should be avoided to be used, typically because it will be or has been superseded</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TemplateStatusCodeLifeCycle">
        <!-- 
            template status (see also HL7 Templates Business Process Requirements Analysis as of January 2012)
            
            Nascent: Under development. Metadata and template may be incomplete. Entered primarily to encourage other users to be aware of ongoing process.
            
            Active: Has been published by the custodian organization and deemed fit for use. May have associated adoption and annotation metadata.
            
            Inactive: Never recommended for use. For example, rejected, withdrawn or found another template fit for use of the one under development. 
            Will not have associated adoption metadata.
            
            Under Update (adoption metadata): adopter adds adoption metadata and/or grouping metadata: these are the only actions an adopter 
            organization can perform. The template(s) in the “under update (adoption metadata” status are unavailable for any other status or 
            metadata changes until the “under update (adoption metadata” action has been completed.
            
            Pre-publication review: the template is complete, pending appropriate review. Entered primarily to encourage other users to be 
            aware of and/or participate in the review process. The custodian organization has not given it an “Active” status (i.e. it has
            not been published); and it may still be rejected (transitioned to an inactive status). E.g. the template may be under ballot by an SDO.
            
            In Review: a post-publication state; may result in a new version or a retirement or no change at all. A new version is one that
            adds clarity but not new intent; the version number is incremented by one, but the identifier is unchanged. A retirement is a 
            template that is no longer fit for purpose, and which may be replaced by a different a template with a different identifier, 
            which is linked to the retired template.
            
            Retired: No longer fit for use. Information available for historical reference.
            
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Life cycle of the Status Code of a Template Design (Version)</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template under development (nascent). Metadata and template may be incomplete. Entered primarily to encourage other users to be aware of ongoing
                        process.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="active">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actief</xforms:label>
                        <xforms:label xml:lang="en-US">Active</xforms:label>
                        <xforms:label xml:lang="de-DE">Aktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template has been published by the governance group (custodian organization) and deemed fit for use. May have associated adoption and annotation metadata.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="retired">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Obsoleet</xforms:label>
                        <xforms:label xml:lang="en-US">Retired</xforms:label>
                        <xforms:label xml:lang="de-DE">Obsolet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template retired: No longer fit for use. Information available for historical reference.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 
                the following states are not really used by template repositories but serve as template registry metadata
            -->
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is rejected. During the development proces of a template design (new, draft) it was decided that
                        further development on this template will not happen.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template was never published and is withdrawn.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="pending">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Onder revisie vóór de publicatie</xforms:label>
                        <xforms:label xml:lang="en-US">Under pre-publication review</xforms:label>
                        <xforms:label xml:lang="de-DE">Unter Revision vor der Publikation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is in pre-publication review: the template is complete, pending appropriate review. Entered primarily to encourage other users to be
                        aware of and/or participate in the review process. The governance group (custodian organization) has not given it an "active" status (i.e. it has not been published); 
                        and it may still be rejected (transitioned to an inactive status)., e.g. the template may be under ballot by an SDO.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="review">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Wordt gereviewed</xforms:label>
                        <xforms:label xml:lang="en-US">In Review</xforms:label>
                        <xforms:label xml:lang="de-DE">In Revision</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is in review: a post-publication state; may result in a new version or a retirement or no change at all. 
                        A new version is one that adds clarity but not new intent (new version date but identifier is unchanged).
                        A retirement is a template that is no longer fit for purpose, and which
                        may be replaced by a different a template (version), which is linked to the retired template.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- begin the following states are not templates DSTU R1 -->
            <!--
            <xs:enumeration value="inactive">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Inactief</xforms:label>
                        <xforms:label xml:lang="en-US">inactive</xforms:label>
                        <xforms:label xml:lang="de-DE">Inaktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template was published but never recommended for use. For example, rejected, withdrawn or found another template fit for use of the one under development. Will not
                        have associated adoption metadata. </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="update">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">In bewerking</xforms:label>
                        <xforms:label xml:lang="en-US">Under update</xforms:label>
                        <xforms:label xml:lang="de-DE">In Bearbeitung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is undergoing an update (adoption metadata): adopter adds adoption metadata and/or grouping metadata: these are the only actions an adopter
                        organization can perform. The template(s) in the "under update (adoption metadata)" status are unavailable for any other status or metadata changes until the "under update
                        (adoption metadata)" action has been completed.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
            <!-- end the following states are not templates DSTU R1 -->
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConceptList">
        <xs:annotation>
            <xs:appinfo>
                <!--sch:pattern name="Validate ConceptList TerminologyAssociation">
                    <sch:rule context="dataset//conceptList[@id]">
                        <sch:let name="pcId" value="(ancestor::concept)[1]/@id"/>
                        <sch:let name="pcType" value="(ancestor::valueDomain)[1]/@type"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:assert role="warning" test="not($pcType='code') or //terminology/terminologyAssociation[@conceptId=$cId]"
                            >WARNING: The concept list <sch:value-of select="$cId"/> inside concept item <sch:value-of select="$pcId"/> SHOULD have a terminologyAssociation</sch:assert>
                    </sch:rule>
                </sch:pattern-->
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConceptListConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this conceptList and may be used to reference it. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a conceptList/@id. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="DataSetConceptListConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Concept TerminologyAssociation</sch:title>
                    <sch:rule context="dataset//conceptList[not(ancestor::history)][not(ancestor::*/@statusCode=('deprecated','cancelled','rejected'))]/concept[@id]">
                        <sch:let name="pcId" value="ancestor::concept[1]/@id"/>
                        <sch:let name="clId" value="parent::conceptList/@id"/>
                        <sch:let name="clHasTermAssoc" value="//terminologyAssociation[@conceptId=$clId]"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:let name="cHasTermAssoc" value="//terminologyAssociation[@conceptId=$cId]"/>
                        <sch:assert role="warning" test="not(exists($clHasTermAssoc)) or exists($cHasTermAssoc)"
                            >WARNING: The concept <sch:value-of select="$cId"/> SHOULD have a terminologyAssociation as the conceptList has a valueSet binding</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept List Item Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional"/>
        <xs:attribute name="exception" type="xs:boolean">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">indicates whether this is an exceptional concept (for example: unknown)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="scenarios">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="actors" type="ActorsDefinition" minOccurs="1" maxOccurs="1"/>
                <xs:element ref="scenario" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="instances" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="instances">
        <xs:complexType>
            <xs:sequence>
                <xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/>
            <xs:attribute name="effectiveDate" type="TimeStampNoTimezone"  use="required"/>
            <xs:attribute name="ref" type="Oid" use="required"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
            <xs:attribute name="process" type="ProcessCode"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="scenario">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="trigger" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="transaction" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/-->
            <xs:attribute name="id" use="required" type="Oid"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="transaction">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Transaction group or singular transaction</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Transaction</sch:title>
                        <sch:rule context="scenario//transaction">
                            <sch:assert test="not(@model) or @type"
                                >ERROR: A transaction with an underlying model SHALL have a @type</sch:assert>
                            <!--<sch:assert test="not(@type='group' and (@effectiveDate or @statusCode))">ERROR: Transaction group SHALL NOT have version attributes @effectiveDate and @statusCode</sch:assert>
                            <sch:assert test="@type='group' or (@effectiveDate and @statusCode)">ERROR: Transaction item SHALL have version attributes @effectiveDate and @statusCode</sch:assert>-->
                            <sch:assert role="error" test="@effectiveDate and @statusCode"
                                >ERROR: Transaction SHALL have version attributes @effectiveDate and @statusCode</sch:assert>
                            <sch:assert role="error" test="not(@label and (transaction or @type='group'))"
                                >ERROR: Transaction groups SHALL NOT have a schematron label</sch:assert>
                            <sch:assert role="error" test="not(representingTemplate[@ref]) or @label"
                                >ERROR: Transaction with a representing template SHALL have a schematron label</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence minOccurs="0">
                <xs:sequence>
                    <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                    <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="trigger" type="TransactionTrigger" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="dependencies" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:choice>
                    <xs:sequence>
                        <xs:element name="actors" type="ActorsReference" minOccurs="1" maxOccurs="1"/>
                        <xs:element ref="representingTemplate" minOccurs="0"/>
                    </xs:sequence>
                    <xs:element ref="transaction" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this transaction</xs:documentation>
                </xs:annotation>
            </xs:attribute-->
            <xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Globally and persistently unique identifier</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="model" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Root element name for the XML structure without namespace prefix that represents this transaction. For HL7 V3 messaging this could be REPC_IN004410UV, for HL7 V2 messaging this could be ADT_A01</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="label" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Constitutes the value for the schematron file with the project prefix (//project/@prefix)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="TransactionType" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="TransactionTrigger">
        <xs:complexContent mixed="true">
            <xs:extension base="FreeFormMarkupWithLanguage">
                <xs:attribute name="id" use="optional" type="xs:NCName"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:simpleType name="TransactionType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows specification of the type of a transaction.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationString">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type group</sch:title>
                            <sch:rule context="transaction[@type='group']" id="TransactionTypeGroup">
                                <sch:assert test="parent::*[1][local-name()='scenario']"> ERROR: Transaction groups SHALL be immediate children of scenario.</sch:assert>
                                <sch:assert test="not(.//transaction[@type='group'])"> ERROR: Transaction groups SHALL NOT contain transaction groups.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'group' groups transactions of other types</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="initial">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Initieel</xforms:label>
                        <xforms:label xml:lang="en-US">Initial</xforms:label>
                        <xforms:label xml:lang="de-DE">Initial</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type initial</sch:title>
                            <sch:rule context="transaction[@type='initial']" id="TransactionTypeInitial">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'initial' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1"> ERROR: Transactions of type 'initial' SHALL have at
                                    least 1 'sender' actor and at least 1 'receiver' actor.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'initial' says that this is the transaction that is initially sent, and usually invokes a response. This transaction type
                        requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="back">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terug</xforms:label>
                        <xforms:label xml:lang="en-US">Back</xforms:label>
                        <xforms:label xml:lang="de-DE">Zurück</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type back</sch:title>
                            <sch:rule context="transaction[@type='back']" id="TransactionTypeBack">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'back' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="preceding-sibling::transaction[@type='initial']"> ERROR: Transactions of type 'back' SHALL be preceded by a transaction of type
                                    'initial'.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1"> ERROR: Transactions of type 'back' SHALL have at least 1
                                    'sender' actor and at least 1 'receiver' actor.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'back' says that this transaction is sent in response to another transaction that preceded this one. Transactions of type
                        'back' may invoke a new transaction, but this is again of type initial. This transaction type requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Registratie</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type stationary</sch:title>
                            <sch:rule context="transaction[@type='stationary']" id="TransactionTypeStationary">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'stationary' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="not(following-sibling::transaction[position()=1][@type='back'])"> ERROR: Transactions of type 'stationary' SHALL NOT be followed by a transaction of
                                    type 'back'.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender'])=1 and count(actors/actor)=1"> ERROR: Transactions of type 'stationary' SHALL have exactly 1 actor of type
                                    'sender'.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'stationary' says that this transaction does not involve communication, but rather the local registration/administration of
                        data. Transactions of type 'stationary' do not invoke new transaction. This transaction type requires exactly one 'sender' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActorsDefinition">
        <xs:sequence>
            <xs:element minOccurs="0" maxOccurs="unbounded" name="actor" type="ActorDefinition"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActorsReference">
        <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" name="actor" type="ActorReference"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActorDefinition">
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="required"/>
        <xs:attribute name="type" type="ScenarioActorType" use="required"/>
        <!-- 2DO should be person|device etc -->
    </xs:complexType>
    <xs:simpleType name="ScenarioActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor type for use in scenarios and transactions</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="person">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Persoon</xforms:label>
                        <xforms:label xml:lang="en-US">Person</xforms:label>
                        <xforms:label xml:lang="de-DE">Person</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Person</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="organization">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Organisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Organization</xforms:label>
                        <xforms:label xml:lang="de-DE">Organisation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Organization</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="device">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Systeem</xforms:label>
                        <xforms:label xml:lang="en-US">Device</xforms:label>
                        <xforms:label xml:lang="de-DE">Gerät</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Device</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActorReference">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor reference references an actor that is defined in the main list of actors for all scenarios</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Actor Reference</sch:title>
                    <sch:rule context="transaction/actors/actor">
                        <sch:let name="actorId" value="@id"/>
                        <sch:assert test="ancestor::scenarios/actors/actor[@id=$actorId]"
                            >ERROR: An actor reference SHALL reference an actor in the main list of actors for all scenarios. <sch:value-of select="$actorId"/> does not exist</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" use="required" type="Oid"/>
        <xs:attribute name="role" type="ActorType"/>
    </xs:complexType>
    <xs:simpleType name="ActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of role the actor plays in a transaction</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="sender">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Zender</xforms:label>
                        <xforms:label xml:lang="en-US">Sender</xforms:label>
                        <xforms:label xml:lang="de-DE">Sender</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the sender of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="receiver">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontvanger</xforms:label>
                        <xforms:label xml:lang="en-US">Receiver</xforms:label>
                        <xforms:label xml:lang="de-DE">Empfänger</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the receiver of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Registratie</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the person or device responsible for persisting the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="representingTemplate">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate sourceDataset with concepts</sch:title>
                        <sch:rule context="scenario[@statusCode=('draft','final','new')]//representingTemplate[@ref]">
                            <sch:let name="ref" value="@ref"/>
                            <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                            <sch:let name="matches" value="//rules/template[(@id|@name)=$ref]/xs:dateTime(@effectiveDate)"/>
                            <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                            <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$ref][@effectiveDate=$flexibility] | //rules/template[@ref=$ref]"/>
                            <sch:assert test="count(concept) = 0 or string-length(@sourceDataset)&gt;0">ERROR: if a representing template contains concept references, a sourceDataset SHALL be present</sch:assert>
                            <sch:assert test="not(@ref) or $reffedTemplate">ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' MUST point to an existing template with flexibility '<sch:value-of select="$flextext"/>' ---<sch:value-of select="$matches"/>---</sch:assert>
                            <sch:assert test="not(@ref) or not($reffedTemplate[@id]) or $reffedTemplate[context]">ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' MUST point to an existing template with a context element</sch:assert>
                        </sch:rule>
                        <sch:rule context="scenario[@statusCode=('draft','final','new')]//representingTemplate[@sourceDataset]">
                            <sch:let name="ref" value="@sourceDataset"/>
                            <sch:let name="flexibility" value="@sourceDatasetFlexibility"/>
                            <sch:let name="reffedDataset" value="//dataset[@id=$ref]"/>
                            <sch:assert role="error" test="count($reffedDataset)&gt;0">ERROR: <sch:name/>/@sourceDataset='<sch:value-of select="$ref"/>' MUST point to an existing dataset.</sch:assert>
                            <sch:assert role="error" test="not($flexibility) or count($reffedDataset[@effectiveDate=$flexibility])&gt;0">ERROR: <sch:name/>/@sourceDataset='<sch:value-of select="$ref"/>' / @sourceDatasetFlexibility='<sch:value-of select="$flexibility"/>' MUST point to an existing dataset.</sch:assert>
                            <sch:assert role="error" test="$flexibility or count($reffedDataset)&lt;2">ERROR: <sch:name/>/@sourceDatasetFlexibility SHALL be present when multiple versions of the dataset exist.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element name="concept" minOccurs="0" maxOccurs="unbounded" type="ScenarioTemplateConcept"/>
            </xs:sequence>
            <!-- Attributes -->
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a template/@id that sets the structure and rules for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this representingTemplate</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceDataset" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a dataset/@id that holds the concept definitions for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceDatasetFlexibility" type="StaticFlexibility" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a dataset/@effectiveDate that holds the concept definitions for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <xs:unique name="uniqueConceptsInRepresentingTemplate">
            <xs:selector xpath="./concept"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="ScenarioTemplateConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate scenario</sch:title>
                    <sch:rule context="representingTemplate/concept[count(ancestor::*[@statusCode])=count(ancestor::*[@statusCode=('draft','new')])]">
                        <sch:assert role="error" test="not(@isMandatory='true' and @minimumMultiplicity='0')"
                            >ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        <sch:assert role="error" test="not(condition[@isMandatory='true' and @minimumMultiplicity='0'])"
                            >ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:assert test="(@minimumMultiplicity or @maximumMultiplicity or @conformance='NP') or (@conformance='C' and count(condition)&gt;0)"
                            >ERROR: a representing template concept SHALL contain cardinality or conditions</sch:assert>
                        <sch:report role="warning" test="@conformance='C' and count(condition)=0"
                            >WARNING: a conditional representing template concept SHOULD contain conditions</sch:report>
                        <sch:report role="warning" test="@conformance='C' and (@minimumMultiplicity or @maximumMultiplicity)"
                            >WARNING: a conditional representing template concept SHOULD have the @minimumMultiplicity and/or @maximumMultiplicity on its conditions</sch:report>
                        <sch:let name="dsid" value="parent::*/@sourceDataset"/>
                        <sch:let name="dseff" value="parent::*/@sourceDatasetFlexibility"/>
                        <sch:let name="reffedDataset" value="//datasets/dataset[@id=$dsid][@effectiveDate=$dseff or not($dseff)]"/>
                        <sch:let name="cid" value="@ref"/>
                        <sch:assert test="$reffedDataset//concept[@id=$cid][not(ancestor::history)][not(parent::conceptList)] or $reffedDataset//concept[@ref]"
                            >ERROR: concept/@id='<sch:value-of select="$cid"/>' MUST exist in dataset/@id='<sch:value-of select="$dsid"/>' @effectiveDate='<sch:value-of select="$reffedDataset/@effectiveDate"/>' (<sch:value-of select="$reffedDataset/name[1]"/>)</sch:assert>

                        <!-- Scenario currently has statusCode and transaction currently doesn't. Check should still work if transaction is to have a statusCode -->
                        <sch:let name="cptStatus" value="//datasets/dataset[@id=$dsid]//concept[@id=$cid][not(parent::conceptList)][not(ancestor::history)]/@statusCode"/>
                        <sch:assert role="warning" test="ancestor::*[not(@statusCode=('draft','new'))] or $cptStatus=('new','draft','final') or string-length($cptStatus)=0"
                            >WARNING: concept/@id='<sch:value-of select="$cid"/>' SHOULD, while you may still edit it, point to a new, draft or final concept, but found '<sch:value-of select="$cptStatus"/>'</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="condition" type="ScenarioTemplateCondition" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list, and is in the dataset that the representing template refers to.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticFlexibility" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@effectiveDate that is not in history or in a concept list, and is in the dataset that the representing template refers to.
                                                   Note: optional for now, but will be required once the conversion for existing projects is in place.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="ScenarioTemplateCondition" mixed="true">
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:element name="ids">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="baseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultBaseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="id" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="identifierAssociation" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="baseId">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">baseId stelt een OID branch voor en koppelt een type en weergavenaam aan die branch. Er MOGEN meerdere verschillende baseId's per type zijn. Een OID kan slechts voor één type worden gebruikt. Verdere toelichting op de branch kan door een id met toelichting te creëren.</xs:documentation>
            <xs:documentation xml:lang="en-US">baseId represents an OID branch and associates a type and a display name to that branch. There MAY be multiple different baseId's per type. An OID can only be used for één type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
            <xs:documentation xml:lang="de-DE">baseId represents an OID branch and associates a type and a display name to that branch. There MAY be multiple different baseId's per type. An OID can only be used for één type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate baseId</sch:title>
                        <sch:rule context="baseId">
                            <sch:assert test="substring(@prefix, string-length(@prefix), 1)='-'" sqf:fix="addHyphenToPrefix">ERROR: baseId prefix SHALL end with "-".</sch:assert>
                            
                            <sch:let name="baseId" value="@id"/>
                            <sch:let name="baseType" value="@type"/>
                            <!--
                                We're in transition some project will be old style, some new.
                                Old style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz"/>
                                    <defaultBaseId id="1.2.3" type="DS"/>
                                New style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz" default="true"/>
                            -->
                            <!--Support old style-->
                            <sch:assert role="error" test="not(../defaultBaseId) or count(parent::ids/defaultBaseId[@type=$baseType])=1" sqf:fix="addMissingDefaultBaseIds"
                                >ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked as default base id</sch:assert>
                            <!--Support new style-->
                            <sch:assert role="error" test="../defaultBaseId or count(parent::ids/baseId[@type=$baseType][@default='true'])=1"
                                >ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked with @default='true'</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="default" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines whether or not this baseId is the default for its @type. There SHALL be exactly only one per type with @default='true'</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultBaseId">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">defaultBaseId stelt de standaard OID branch voor, voor een bepaalde type. Bij het toekennen van id's aan DECOR objecten wordt deze branch gebruikt als identificatiesysteem. Er MOET exact één defaultBaseId per type zijn. Voor iedere defaultBaseId MOET ook een baseId met hetzelfde type bestaan. Verdere toelichting op de branch kan door een id met toelichting te creëren.</xs:documentation>
            <xs:documentation xml:lang="en-US">defaultBaseId represents the default OID branch for a given type. This branch is used as identifier system in assigning ids to DECOR objects. There SHALL be exactly one defaultBaseId per type. For every defaultBaseId there SHALL also be a baseId with a mtching type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
            <xs:documentation xml:lang="de-DE">defaultBaseId represents the default OID branch for a given type. This branch is used as identifier system in assigning ids to DECOR objects. There SHALL be exactly one defaultBaseId per type. For every defaultBaseId there SHALL also be a baseId with a mtching type. Further explanation for the branch can be added by adding an id with descriptive text.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate defaultBaseId type</sch:title>
                        <sch:rule context="defaultBaseId">
                            <sch:let name="dbt" value="@type"/>
                            <sch:assert test="count(preceding-sibling::defaultBaseId[@type = $dbt])=0">ERROR: defaultBaseId type SHALL be unique with project.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="id">
        <xs:annotation>
            <xs:documentation xml:lang="nl-NL">Met id geeft u toelichting op diverse ID's in relatie tot het project.</xs:documentation>
            <xs:documentation xml:lang="en-US">With id you give more information about ID related to the project.</xs:documentation>
            <xs:documentation xml:lang="de-DE">With id you give more information about ID related to the project.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="property" type="ArbitraryPropertyType" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="nl-NL">Id eigenschappen bijvoorbeeld voor het verbinden van dit id met andere typen identificatie (bijv. HL7 FHIR Systeem URI) voor hetzelfde object (codesysteem, OID-tak, identificatiesysteem). Als u van plan bent een HL7 FHIR System URI te verbinden die de voorkeur heeft boven de OID, gebruikt u dan @name='HL7-FHIR-System-URI-Preferred'. Als er wel een HL7 FHIR System URI bestaat maar deze niet de voorkeur heeft boven de OID, gebruikt u dan 'HL7-FHIR-System-URI'. Op deze manier herkent ART-DECOR deze indien van toepassing.</xs:documentation>
                        <xs:documentation xml:lang="en-US">Id properties for example to connect this id to other types of identifiers (e.g. HL7 FHIR System URI) for the same object (code system, OID branch, identification system) If you intend to connect an HL7 FHIR System URI that is preferred over the OID, please use @name='HL7-FHIR-System-URI-Preferred'. When you connect an HL7 FHIR System URI that exists but is not preferred over the OID, please use 'HL7-FHIR-System-URI'. This way ART-DECOR can pick it up if appropriate.</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="root" use="required" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
            <xs:attribute name="assigningAuthority" type="LongDescriptiveName"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="identifierAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">identifierAssociation links a dataset conceptList to an identifier scheme. Any conceptList may have multiple of these associations</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate identifierAssociation</sch:title>
                        <sch:rule context="identifierAssociation[not(@expirationDate)]">
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="conceptId" value="@conceptId"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="//datasets/dataset//conceptList[@id=$conceptId][parent::valueDomain/@type=('identifier')] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing conceptList under a value domain of type identifier</sch:assert>
                            
                            <sch:assert role="error" test="not(//terminologyAssociation[@conceptId=$conceptId])"
                                >ERROR: co-occurrence violation. A concept(List) MUST NOT be associated with terminology AND an identifier scheme</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment MUST have a project unique id so you can attach issues, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <xs:attribute name="conceptId" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">conceptList id this assocication is associated with, applies always to all conceptLists with that id or ref, regardless of its effectiveDate or statusCode</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Object Identifier (OID) of the identification scheme this assocication is associated with. Example: '2.16.840.1.113883.4.1' for US Social Security Numbers</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
        </xs:complexType>
    </xs:element>
    <xs:element name="issues">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate issues ids</sch:title>
                        <sch:rule context="issue">
                            <sch:let name="iid" value="@id"/>
                            <sch:assert test="count(preceding-sibling::issue[@id = $iid])=0">ERROR: issue id SHALL be unique with project.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element ref="labels" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="issue" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify all authors of the project about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="NotifierOnOff">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Automatic notifier system (if activated) notifies all authors of the project about changes of any project issue on/off</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="on">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notificaties aan</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier on</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier on</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier on</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="off">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notificaties uit</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier off</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier off</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier off</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="labels">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Contains definition of labels specific to this DECOR instance. A DECOR instance does require labeling of issues. 
                However once a label is used you SHOULD NOT alter/remove the label.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="label" minOccurs="1" maxOccurs="unbounded" type="IssueLabelDefinition"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="uniqueLabelCode">
            <xs:selector xpath=".//label"/>
            <xs:field xpath="./@code"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="IssueLabelDefinition">
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Describes what the label is meant to represent/do</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="color" type="HTMLColorName" use="optional" default="white">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains an HTML compatible reference to a color. Examples for the color red: red, #ff0000, rgb(255,0,0)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="code" type="EnumerationString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a code that may be used to refer to this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a descriptive name for this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="issue">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate tracking/assignment labels</sch:title>
                    <sch:rule context="issue/tracking|issue/assignment">
                        <sch:let name="labelRef" value="for $lbl in tokenize(@labels,' ') return exists(ancestor::issues[last()]/labels/label[@code=$lbl])"/>
                        <sch:assert role="warning" test="not(@labels) or count(index-of($labelRef,false()))=0">WARNING: <sch:name/>/@labels SHOULD reference defined label codes.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="object" minOccurs="0" maxOccurs="unbounded" type="IssueObject"/>
                <xs:choice minOccurs="1" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The list of historic events in terms of comments tracking and assignments</xs:documentation>
                    </xs:annotation>
                    <xs:element name="tracking" minOccurs="1" maxOccurs="unbounded" type="IssueTracking"/>
                    <xs:element name="assignment" minOccurs="0" maxOccurs="unbounded" type="IssueAssignment"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The unique id of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="IssueType" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The type of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="priority" type="IssuePriority" use="optional" default="N">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The priority level of this issue, defaults to normal</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A short text to describe the issue (headline)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="IssueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Kind of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="INC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Storing</xforms:label>
                        <xforms:label xml:lang="en-US">Incident</xforms:label>
                        <xforms:label xml:lang="de-DE">Störung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Incident</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RFC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Wijzigingsverzoek</xforms:label>
                        <xforms:label xml:lang="en-US">Change Request</xforms:label>
                        <xforms:label xml:lang="de-DE">Änderungswunsch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Change Request</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FUT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voor de toekomst</xforms:label>
                        <xforms:label xml:lang="en-US">For future consideration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zur zukünftigen Berücksichtigung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future consideration</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CLF">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verduidelijking/toelichting noodzakelijk</xforms:label>
                        <xforms:label xml:lang="en-US">Request for Information/Education</xforms:label>
                        <xforms:label xml:lang="de-DE">Bitte um Information/Aufklärung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Request for Information/Education</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IssuePriority">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Priority of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="HH">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoogste</xforms:label>
                        <xforms:label xml:lang="en-US">Highest</xforms:label>
                        <xforms:label xml:lang="de-DE">Höchste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Highest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="H">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoog</xforms:label>
                        <xforms:label xml:lang="en-US">High</xforms:label>
                        <xforms:label xml:lang="de-DE">Hoch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">High</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="N">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Normaal</xforms:label>
                        <xforms:label xml:lang="en-US">Normal</xforms:label>
                        <xforms:label xml:lang="de-DE">Normal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Normal</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laag</xforms:label>
                        <xforms:label xml:lang="en-US">Low</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Low</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laagst</xforms:label>
                        <xforms:label xml:lang="en-US">Lowest</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrigste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Lowest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueObject">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The object(s) that are subject to the issue</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate issue object</sch:title>
                    <sch:rule context="issue/object">
                        <sch:assert test="@id or @name">ERROR: issue object SHALL have an id or a name.</sch:assert>
                        <sch:assert test="@id or (@name and @flexibility)">ERROR: if issue object has a name only, flexibility SHALL be stated.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The id of the object that is subject to the issue; either id or name of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The name of the object that is subject to the issue; either name or id of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="IssueObjectType" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The type of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The optional effectiveDate of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="IssueObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The type of the object that is subject to an issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="DecorObjectType">
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een value set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- KH 20140606: no longer supported 
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is an template element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een transactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist eine Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Issue</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with reference to another issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met een relatie naar een ander issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt relatiert mit ein Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 2014-07-16 AH Added -->
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueTracking">
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="1"/>
            <xs:element name="desc" minOccurs="1" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this tracking</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the tracking.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="IssueStatusCodeLifeCycle" use="required"/>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="IssueAssignment" mixed="true">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The assignment of an issue to a person or group</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The id of the author of this assignment</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this assignment</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="to" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifier of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name / label of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the assignment of the issue.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="IssueStatusCodeLifeCycle">
        <!-- 
            (start) - > new
            a new issue has been created, not yet finished
            
            new - > open
            a new issue has been opened, ready for action
            
            open - > inprogress
            the work on this issue is in progress
            
            open/inprogress - > feedback - > inprogress
            if further information or feedback on an issue is needed
            once the information is available the status can get back to inprogress
            
            open/inprogress - > rejected (end)
            an issue has been found to be rejected no further action is taken on the issue
            
            open/inprogress - > deferred - > inprogress
            open/inprogress - > deferred - > closed (end)
            an issue has been found to be deferred for future action and
            - further action is taken on the issue later
            - the issue is closed later
            
            open/inprogress - > referred (end)
            an issue has been found to be referred to other entities to take action on the issue
            
            cancelled
            at any time an issue may be cancelled (end)
            
            resolved
            an open/closed issue may proceed to resolved at any time
            
            the often found status "assigned" is detectable (if there is an assignee), not a status
            
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Life cycle of the status code of an issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="new">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Nieuw</xforms:label>
                        <xforms:label xml:lang="en-US">New</xforms:label>
                        <xforms:label xml:lang="de-DE">Neu</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue just created. It is new and will soon become a draft/open/finalized issue. Beyond the author, nobody should look at this issue unless it's
                        status code is open or beyond.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="open">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Open</xforms:label>
                        <xforms:label xml:lang="en-US">Open</xforms:label>
                        <xforms:label xml:lang="de-DE">Offen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is open, ready for actions to take on, also open for comments</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="inprogress">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">In behandeling</xforms:label>
                        <xforms:label xml:lang="en-US">In Progress</xforms:label>
                        <xforms:label xml:lang="de-DE">In Bearbeitung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is in progress</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="feedback">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Feedback nodig</xforms:label>
                        <xforms:label xml:lang="en-US">Feedback needed</xforms:label>
                        <xforms:label xml:lang="de-DE">Feedback nötig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is in progress but needs feedback from others</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="closed">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gesloten</xforms:label>
                        <xforms:label xml:lang="en-US">Closed</xforms:label>
                        <xforms:label xml:lang="de-DE">Geschlossen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is closed including an solution</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is rejected</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="deferred">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Uitgesteld</xforms:label>
                        <xforms:label xml:lang="en-US">Deferred</xforms:label>
                        <xforms:label xml:lang="de-DE">Zurückgestellt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is deferred</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is cancelled</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="templateId">
        <xs:complexType>
            <xs:attribute name="root" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="NullFlavorPattern">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="nullFlavor">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="VocabType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Vocab Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">L Leaf; a term that has no children in the specialization hierarchy, and is selectable, and therefore deemed to be a leaf.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="A">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A Abstract; a term that has children in the specialization hierarchy, but is not, itself, selectable and therefore deemed
                        abstract.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="S">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">S Specializable; a term that has children in the specialization hierarchy, and is also selectable and therefore deemed
                        specializable.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="D">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">D Deprecated; a term that should not be used any longer</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ConformanceType">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Conformancetype</xforms:label>
                <xforms:label xml:lang="en-US">Conformance Type</xforms:label>
                <xforms:label xml:lang="de-DE">Conformance Typ</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Conformance Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="R">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Required</xforms:label>
                        <xforms:label xml:lang="en-US">Required</xforms:label>
                        <xforms:label xml:lang="de-DE">Required</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">R required</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="C">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conditioneel</xforms:label>
                        <xforms:label xml:lang="en-US">Conditional</xforms:label>
                        <xforms:label xml:lang="de-DE">Conditional</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">C conditional</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NP">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Niet aanwezig</xforms:label>
                        <xforms:label xml:lang="en-US">Not present</xforms:label>
                        <xforms:label xml:lang="de-DE">Nicht erlaubt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">NP not present</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="OidOrNullFlavor">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows both OIDs for codesystems or special 'nullFlavor'</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="Oid NullFlavorPattern"/>
    </xs:simpleType>
    <xs:element name="terminology">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="terminologyAssociation" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="codeSystem" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="valueSet" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="terminologyAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">terminologyAssociation links a concept to a code or a concept list to a value set</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate terminologyAssociation</sch:title>
                        <sch:rule context="terminologyAssociation[not(@expirationDate)]">
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="conceptId" value="@conceptId"/>
                            <sch:let name="valuesetRef" value="@valueSet"/>
                            <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//terminology/valueSet[@id=$valuesetRef or @name=$valuesetRef]/xs:dateTime(@effectiveDate)))"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="not(@valueSet) or //datasets/dataset//conceptList[@id=$conceptId] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing conceptList</sch:assert>
                            <sch:assert role="warning" test="not(@code) or //datasets/dataset//concept[@id=$conceptId] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing concept or concept within a conceptList</sch:assert>
                            <sch:assert test="not(@valueSet) or //terminology/valueSet[(@id,@ref,@name)=$valuesetRef][@ref or @effectiveDate=$flexibility]">ERROR: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' MUST point to an existing valueSet '<sch:value-of select="$valuesetRef"/>' and if applicable with the correct @flexibility</sch:assert>
                            <sch:assert test="@code or @valueSet">ERROR: terminologyAssociation object SHALL have a @code or a @valueSet</sch:assert>
                            <sch:assert test="not(@code and @valueSet)">ERROR: terminologyAssociation object SHALL have a @code or a @valueSet but not both</sch:assert>
                            <sch:assert test="not(@code and @flexibility)">ERROR: if terminologyAssociation object has a @code it SHALL NOT have @flexibility</sch:assert>
                            <sch:assert role="warning" test="not(@valueSet) or matches(@valueSet,'^[0-9\.]+$')"
                                >ERROR: <sch:name/> references to a value set SHOULD be based on valueSet/@id. References by @name quickly become ambiguous</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment SHOULD have a project unique id so you can attach issues, manage the status machine, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <!-- concept id where this assocication is associated with -->
            <xs:attribute name="conceptId" use="required" type="Oid"/>
            <xs:attribute name="conceptFlexibility" use="optional" type="StaticFlexibility">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Refers to the concept/@effectiveDate if conceptId points to a real concept and not to conceptList or a concept under a conceptList.</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- a coded concept -->
            <xs:attribute name="code" use="optional" type="EnumerationString"/>
            <xs:attribute name="codeSystem" use="optional" type="Oid"/>
            <!-- human readable things for codes -->
            <xs:attribute name="codeSystemName" use="optional" type="NonEmptyString"/>
            <xs:attribute ref="displayName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A displayname for the code, only for human readablility here</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- a value set and flexibility -->
            <xs:attribute name="valueSet" type="BasicIdOrOid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
        </xs:complexType>
    </xs:element>
    <xs:element name="valueSet">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Value Set. A DECOR valueSet can take different forms. It may be a simple value set reference (@ref) to a value set from a repository without any contents, id, effectiveDate or statusCode, but with a name and a displayName. The other option is a valueSet with contents, id, effectiveDate, statusCode, name and displayName.</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate value set object</sch:title>
                    <sch:rule context="terminology/valueSet">
                        <sch:assert test="@id or @ref">ERROR: Value set object SHALL have an @id or a @ref</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Value set object SHALL have an @id or a @ref but not both</sch:assert>
                        <sch:assert test="@ref or (@id and (conceptList/(concept|include[not(string(@exception)='true')]) or completeCodeSystem))">ERROR: Value set object with an @id SHALL have conceptList with concepts or completeCodeSystem</sch:assert>
                        <sch:assert test="not(@ref and (@*[not(name()=('ref','name','displayName'))] or conceptList or completeCodeSystem))">ERROR: Value set object with a @ref SHALL NOT have other attributes than @name or @displayName or have a conceptList or completeCodeSystem</sch:assert>
                        <!--<sch:assert test="not(completeCodeSystem and conceptList/(concept|include[not(string(@exception)='true')]))">ERROR: Value set MUST NOT reference codeSystems AND concepts.</sch:assert>-->
                        <sch:assert test="(@id and @effectiveDate) or @ref">ERROR: Value set object with an @id SHALL have an @effectiveDate</sch:assert>
                    </sch:rule>
                    <sch:rule context="valueSet/conceptList/exception">
                        <sch:let name="theCode" value="@code"/>
                        <sch:let name="theCodeSystem" value="@codeSystem"/>
                        <sch:assert test="not(preceding-sibling::exception[@code=$theCode][@codeSystem=$theCodeSystem])">ERROR: Value Set exception SHALL be unique within the same value set</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- Only relevant after compilation -->
                <xs:group ref="ValueSetCompilationSourceCodeSystem"/>
                <!-- 
                    there may be one publishing and one or more endorsing authorities
                    not used by DECOR yet
                -->
                <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Value set for (clinical) accuracy and relevance, 
                            and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Value set for (clinical) accuracy and relevance, and endorsed it for use</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- FHIR Value Set DSTUr1 0.8 compatibility -->
                <xs:element name="copyright" type="NonEmptyString" minOccurs="0" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A copyright statement relating to the value set and/or its contents. 
                            Comment: Frequently, the copyright differs between the value set, and codes that are included. The copyright 
                            statement should clearly differentiate between these when required.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- 
                    there may be 0..* value set revision history discriptions
                    not used by DECOR yet
                -->
                <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Value set
                            as compared to the previous version. Since Value set versions are built off of previous versions, the net effect 
                            of this field is to function as a comprehensive historical reference of the Value set.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="completeCodeSystem" type="CodeSystemReference" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="conceptList" type="ValueSetConceptList" minOccurs="0" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this value set and may be used to reference it. Value sets SHOULD carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id. Value sets SHALL carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- Only relevant after compilation -->
            <xs:attributeGroup ref="ValueSetCompilationAttributes"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemReference">
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a codeSystem/@codeSystem. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="ValueSetConceptList">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="concept" type="ValueSetConcept"/>
                <xs:element name="include" type="ValueSetRef"/>
            </xs:choice>
            <xs:element name="exception" type="ValueSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ValueSetConcept">
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the designation/description of the coded concept</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="code" type="EnumerationString" use="required"/>
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="displayName" use="required"/>
        <xs:attribute name="level" type="xs:integer" use="required"/>
        <xs:attribute name="type" type="VocabType" use="required"/>
    </xs:complexType>
    <xs:complexType name="ValueSetRef">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Include of another valueSet, typically from a repository, but potentially within the same DECOR definition.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the description of the referenced value set</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@id.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exception" use="optional" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Indicates whether the valueSet contents should be treated as exceptions. Default is 'false' meaning that the contents are included as concepts.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="codeSystem">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Code system</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate code system object</sch:title>
                    <sch:rule context="codeSystem">
                        <sch:assert test="@id or @ref">ERROR: Code system object SHALL have an @id or a @ref.</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Code system object SHALL have an @id or a @ref but not both</sch:assert>
                        <sch:assert test="@ref or (@id and conceptList)">ERROR: A code system object with an @id SHALL have a conceptList</sch:assert>
                        <sch:assert test="@ref or (@id and @effectiveDate)">ERROR: A code system object with an @id SHALL have an @effectiveDate</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A description that describes the Code System</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="conceptList" type="CodeSystemConceptList" minOccurs="0" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A version identifier that uniquely identifies each version of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A reference to a version identifier of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a codeSystem/@codeSystem. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemConceptList">
        <xs:sequence>
            <xs:element ref="codedConcept" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:element name="codedConcept">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A language symbol for the concept that is intended to convey the concept meaning to a human being. It may contain multiple designations per
                            language to expres preferences, synonyms etc. For example, in SNOMED CT, the concept of "fever" has the fully specified name of "fever (finding)", a preferred name of
                            "fever", and synonyms of "febrile" and "pyrexia". These are all designations in English for the concept of "fever".</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="code" type="EnumerationString" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">An identifier that uniquely names the class or "concept" within the context of the defining Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="statusCode" type="NonEmptyString" use="optional" default="active">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Status of the "concept", in this context only "active" concepts are listed</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="level" type="xs:integer" use="required"/>
            <xs:attribute name="type" type="VocabType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="designation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A description for the designation</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate FreeFormMarkupWithLanguage designation</sch:title>
                        <sch:rule context="designation[not(ancestor::example)]">
                            <sch:assert role="error" test="not(preceding-sibling::*[name()=name(current())][@language=current()/@language][@type='preferred' and current()/@type='preferred'])">ERROR: Each repetition of <sch:name path=".."/>/<sch:name/> with language SHALL be a different language, or only one SHALL be marked 'preferred'</sch:assert>
                            <sch:assert role="warning" test="@language">WARNING: Each repetition of <sch:name path=".."/>/<sch:name/> SHOULD be qualified with @language</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:complexContent>
                <xs:extension base="FreeFormMarkupWithLanguage">
                    <xs:attribute name="type" type="DesignationType" use="optional">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">Type of designation (for that langauge), preferred, synonym, abbreviation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute ref="displayName" use="required">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DesignationType">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="preferred">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">preferred</xforms:label>
                        <xforms:label xml:lang="nl-NL">preferent</xforms:label>
                        <xforms:label xml:lang="de-DE">bevorzugt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">preferred</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="synonym">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">synonym</xforms:label>
                        <xforms:label xml:lang="nl-NL">synoniem</xforms:label>
                        <xforms:label xml:lang="de-DE">synonym</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">synonym</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="abbreviation">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">abbreviation</xforms:label>
                        <xforms:label xml:lang="nl-NL">afkorting</xforms:label>
                        <xforms:label xml:lang="de-DE">Abkürzung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">abbreviation</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="rules">
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="templateAssociation" type="TemplateAssociationDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="template" type="TemplateDefinition" minOccurs="1" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:complexType>
        <!-- Cannot have two templates carrying the same id and effectiveDate -->
        <xs:unique name="templateuniquekey">
            <xs:selector xpath="./template"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <!-- Cannot have two templateAssociations for the same template (based on id and effectiveDate) -->
        <xs:unique name="templateAssociationuniquekey">
            <xs:selector xpath="./templateAssociation"/>
            <xs:field xpath="@templateId"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="TemplateAssociationDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Definition</sch:title>
                    <!-- <templateAssociation templateId="2.16.840.1.113883.2.4.6.10.100.13" effectiveDate="2012-05-09T00:00:00"> -->
                    <sch:rule context="templateAssociation">
                        <sch:let name="templateId" value="@templateId"/>
                        <sch:let name="effectiveDate" value="@effectiveDate"/>
                        <sch:assert test="//rules/(template[@id=$templateId][@effectiveDate=$effectiveDate]|template[@ref=$templateId])"
                            >ERROR: A template association SHALL be bound with a template with the same id and effective date</sch:assert>
                        
                        <sch:assert test="count(../templateAssociation[@templateId=$templateId][@effectiveDate=$effectiveDate])&lt;=1"
                            >ERROR: There SHALL be 0..1 template association per template (<sch:value-of select="$templateId"/> - <sch:value-of select="$effectiveDate"/>)</sch:assert>
                        <!-- 2DO a template has 0..1 templateAssociation -->
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="TemplateAssociationConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="templateId" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@id where this template association is referring to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@effectiveDate where this template association is referring to (should 
                    actually be named templateEffectiveDate according to the other attribute @templateId</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="TemplateAssociationConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Concept</sch:title>
                    <!-- <concept ref="2.16.840.1.113883.2.4.3.11.60.100.2.4.472" effectiveDate="2012-05-20T14:12:37" elementId="2.16.840.1.113883.2.4.3.11.60.100.9.13.2"/> -->
                    <sch:rule context="templateAssociation/concept">
                        <sch:let name="templateId" value="parent::templateAssociation/@templateId"/>
                        <sch:let name="templateEffectiveDate" value="parent::templateAssociation/@effectiveDate"/>
                        <sch:let name="conceptId" value="@ref"/>
                        <sch:let name="conceptEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="datasetConcept" value="//datasets//concept[@id=$conceptId][not(@effectiveDate) or @effectiveDate=$conceptEffectiveDate][not(ancestor::history)]"/>
                        <sch:let name="elementId" value="@elementId"/>
                        <sch:let name="templateIsRef" value="ancestor::rules/template[@ref=$templateId]"/>
                        <sch:let name="template" value="ancestor::rules/template[@id=$templateId][@effectiveDate=$templateEffectiveDate]"/>
                        <sch:let name="templateElement" value="$template//*[@id=$elementId]"/>
                        <sch:assert test="$template[@statusCode=('cancelled','rejected','retired')] or $datasetConcept"
                            >ERROR: A template association concept SHALL be bound to a concept with same id and (if indicated) effective date</sch:assert>
                        <sch:assert role="error" test="$template[@statusCode=('cancelled','rejected','retired')] or $templateElement or $templateIsRef"
                            >ERROR: A template association concept SHALL be bound to an element with the indicated id '<sch:value-of select="$elementId"/>' in the indicated template with the same id and effective date</sch:assert>
                        
                        <sch:let name="termAssocsConcept" value="//terminologyAssociation[@conceptId=($datasetConcept/@id|$datasetConcept/inherit/@ref)]"/>
                        <sch:let name="tempElement" value="$templateElement[matches(@name,'^[^:]+:value')]/preceding-sibling::element[matches(@name,'^[^:]+:code')]"/>
                        <sch:assert role="warning" test="$template[@statusCode=('cancelled','rejected','retired')] or not($datasetConcept) or not($tempElement) or not($termAssocsConcept) or $termAssocsConcept[concat(@code,'#',@codeSystem)=$tempElement/vocabulary/concat(@code,'#',@codeSystem)]"
                            >WARNING: Element '<sch:value-of select="$tempElement/@name"/>' (id=<sch:value-of select="$elementId"/>) is not bound to the same code as the dataset concept<sch:value-of select="concat(' ''',$datasetConcept/name[1],'''')"/>. 
                            Found "code='<sch:value-of select="$tempElement/vocabulary/@code"/>' codeSystem='<sch:value-of select="$tempElement/vocabulary/@codeSystem"/>'", expected "code / codeSystem='<sch:value-of select="distinct-values($termAssocsConcept/concat(@code,' / ',@codeSystem))"/>'"</sch:assert>
                        
                        <!--<sch:let name="conceptIsItem" value="if ($datasetConcept) then exists(//datasets//concept[@id=$conceptId][not(@effectiveDate) or @effectiveDate=$conceptEffectiveDate][not(ancestor::history)][@type='item' or not(concept)][not(valueDomain/@type='complex')]) else (false())"/>-->
                        <!--<sch:let name="elementHasDatatype" value="if ($templateElement) then ancestor::rules/template[@id=$templateId][@effectiveDate=$templateEffectiveDate]//*[@id=$elementId][@datatype] else()"/>-->
                        <!--<sch:assert role="warning" test="not($templateElement) or not($conceptIsItem) or $elementHasDatatype"
                            >WARNING: Concept item <sch:value-of select="$conceptId"/> (<sch:value-of select="$conceptEffectiveDate"/>) SHOULD probably be bound to an element with a datatype</sch:assert>-->
                        
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
        <xs:attribute name="elementId" type="Oid" use="required"/>
    </xs:complexType>
    <xs:complexType name="TemplateDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]">
                        <sch:let name="id" value="@id"/>
                        
                        <sch:assert test="@id or @ref">ERROR: Template object SHALL have an @id or a @ref</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Template object SHALL have an @id or a @ref but not both</sch:assert>
                        
                        <sch:assert test="(@id and @effectiveDate) or @ref">ERROR: Template object with an @id SHALL have an @effectiveDate</sch:assert>
                        
                        <sch:assert test="not(context[@id='*']) or element[matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[@root=$id or (@name='root' and @value=$id)]"
                            >ERROR: if context of template is * an element named templateId (e.g. hl7:templateId) shall be defined with an attribute @root id (or name value pair) of that template</sch:assert>
                        <sch:assert test="not(context[@id='**']) or */element[matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[@root=$id or (@name='root' and @value=$id)]"
                            >ERROR: if context of template is ** an element named templateId (e.g. hl7:templateId) shall be defined with an attribute @root id (or name value pair) of that template</sch:assert>
                        
                        <sch:assert test="not(@id and (@*[name()=('ref','flexibility')]))"
                            >ERROR: template with a @id SHALL NOT have attributes @ref or @flexibility</sch:assert>
                        <sch:assert test="not(@ref and (@*[not(name()=('ref','name','displayName','url','ident'))] or *[not(name()='desc')]))"
                            >ERROR: template with a @ref SHALL NOT have other attributes than @name or @displayName and MAY have description</sch:assert>
                        
                        <sch:assert role="error" test="@ref or (@effectiveDate and @statusCode)"
                            >ERROR: template SHALL have @ref or (@effectiveDate and @statusCode)</sch:assert>
                        
                    </sch:rule>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//*[name()=('attribute','element','include','constraint','let','defineVariable','assert','report')]">
                        <sch:let name="name" value="name()"/>
                        <sch:let name="duplicates" value="concat(@name,@ref,@contains,@test)=following-sibling::*[name()=$name]/concat(@name,@ref,@contains,@test)"/>
                        <sch:assert role="warning" test="not($duplicates)"
                            >WARNING: <sch:name/> has sibling <sch:name/> particles that carry the same values for the attribute @name,@ref,@contains,@test. This could lead to merge problems in editing templates based on this templates. Consider adding predicates or updating the test clause to make these particles distinct.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of template -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
             <!-- the type(s) etc of the template, for later use -->
            <xs:element name="classification" type="TemplateProperties" minOccurs="0" maxOccurs="unbounded"/>
            <!-- relationships of this template -->
            <xs:element name="relationship" type="TemplateRelationships" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Template Relationship</sch:title>
                            <sch:rule context="template/relationship">
                                <sch:assert role="error" test="(@template or @model) and not(@template and @model)"
                                    >ERROR: must have either <sch:name/>/@template or <sch:name/>/@model, and not both</sch:assert>
                                <sch:assert role="error" test="not(@model) or @type='DRIV'"
                                    >ERROR: <sch:name/> to a model SHALL be 'DRIV' (derived)</sch:assert>
                                <sch:assert role="warning" test="not(@template) or matches(@template,'^[0-9\.]+$')"
                                    >ERROR: <sch:name/> references to a template SHOULD be based on template/@id. References by @name quickly become ambiguous</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
            </xs:element>
            <!-- context of template
                either
                <context id="*"/> for an element templateId context
                or <context path="//"/> for a specific context path
            -->
            <xs:element ref="context" minOccurs="0" maxOccurs="1"/>
            <!-- item reference and description(s), inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..n inherit definitions before others in a template (indicating parent / sibling templates)
                not used by DECOR yet
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                there may be one publishing and one or more endorsing authorities
                not used by DECOR yet
            -->
            <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Template for (clinical) accuracy and relevance, 
                        and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Template for (clinical) accuracy and relevance, 
                        and endorsed it for use</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- 
                there may be 0..* template revision history discriptions
                not used by DECOR yet
            -->
            <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Template as compared to the previous version. 
                        Since Template versions are built off of previous versions, the net effect of this field is to function as a
                        comprehensive historical reference of the Template.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- 
                the design body: elements, attributes, choices or includes
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The identifying OID of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id. Templates SHALL carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortFormalName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The mnemonic name of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="TemplateStatusCodeLifeCycle" use="optional"/>
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        
        <!-- Only relevant after compilation -->
        <xs:attributeGroup ref="TemplateCompilationAttributes"/>
    </xs:complexType>
    <xs:complexType name="AuthorityType" mixed="true">
        <xs:sequence>
            <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Id of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="NonEmptyString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!--<xs:attribute name="email" type="EmailType" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Email address of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>-->
    </xs:complexType>
    <xs:complexType name="ObjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="NonEmptyString"/>
    </xs:complexType>
    <xs:complexType name="TemplateProperties">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The classification of the template</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="tag" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, tag elements could be incorporated to specifiy any number of tags for search purposes</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, property elements could be incorporated to specifiy any number of properties not part of the standard metadata, e.g. for operationalization instructions</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="type" type="TemplateTypes" use="required"/>
        <xs:attribute name="format" type="TemplateFormats" use="optional" default="hl7v3xml1"/>
    </xs:complexType>
    <xs:simpleType name="TemplateTypes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The type of the template, something like "cdaentrylevel", "cdasectionlevel", "messagelevel" etc.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="cdadocumentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA document level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Document Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Document Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Document Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="messagelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 message level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 Message Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 Message Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 Message Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaheaderlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA header level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Header Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Header Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Header Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdasectionlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA section level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Section Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Section level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Section Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaentrylevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA entry level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA Entry Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA Entry Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA Entry Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="segmentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2 segment level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2 Segment Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2 Segment Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 Segment Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="clinicalstatementlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Clinical Statement level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Clinical Statement Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Clinical Statement Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Clinical Statement Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="controlactlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Control Act level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Control Act Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Control Act Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Control Act Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="payloadlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Payload level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Payload Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Payload Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Payload Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datatypelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 datatype level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 Datatype Level Template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 Datatype Level Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 Datatype Level Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="notype">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Templatetype niet gespecificeerd</xforms:label>
                        <xforms:label xml:lang="en-US">Template type not specified</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Typ nicht spezifiziert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template type not specified</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="TemplateRelationships">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The relationships of the template regarding other templates or model artifacts</xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="RelationshipTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the relationship of the template, at this point in time something like "SPEC", "GEN", "EQUIV", "VERSION", etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="template" type="BasicIdOrOid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference by name or id to a template identifer, used for template-template relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="model" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference to a model artifact identifier or description specifying from what this template is derived from or based on, e.g. an HL7 R-MIM, a DCM,
                    used for template-model relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="RelationshipTypes">
        <xs:restriction base="xs:NMTOKEN">
            <!-- Template-template relationships -->
            <xs:enumeration value="REPL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Vervanging</xforms:label>
                        <xforms:label xml:lang="en-US">Replacement</xforms:label>
                        <xforms:label xml:lang="de-DE">Ersatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template replaces @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SPEC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Specialisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Specialization</xforms:label>
                        <xforms:label xml:lang="de-DE">Spezialisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template specializes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="GEN">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Generalisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Generalization</xforms:label>
                        <xforms:label xml:lang="de-DE">Generalisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template generalizes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="COPY">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Kopie</xforms:label>
                        <xforms:label xml:lang="en-US">Copy</xforms:label>
                        <xforms:label xml:lang="de-DE">Kopie</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a design copy of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ADAPT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Adaptatie</xforms:label>
                        <xforms:label xml:lang="en-US">Adaptation</xforms:label>
                        <xforms:label xml:lang="de-DE">Adaptation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is an adaptation of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EQUIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Equivalent</xforms:label>
                        <xforms:label xml:lang="en-US">Equivalent</xforms:label>
                        <xforms:label xml:lang="de-DE">Equivalent</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is equivalent to @template regarding design</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VERSION">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Versie</xforms:label>
                        <xforms:label xml:lang="en-US">Versie</xforms:label>
                        <xforms:label xml:lang="de-DE">Version</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a version of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BACKWD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Backward compatible</xforms:label>
                        <xforms:label xml:lang="en-US">Backward Compatible</xforms:label>
                        <xforms:label xml:lang="de-DE">Rückwärtskompatibel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is backward compatible of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- Template-model relationships -->
            <xs:enumeration value="DRIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgeleide</xforms:label>
                        <xforms:label xml:lang="en-US">Derived</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgeleitet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future use: This template is derived from model or other artifact expressed or specified in the @template attribute</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TemplateFormats">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">As of now only a few formats are supported, e.g. "HL7 V3 XML ITS 1" = hl7v3xml1</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="hl7v3xml1">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V3 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V3 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="hl7v2.3.1xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="hl7v2.4xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.4 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
            <xs:enumeration value="hl7v2.5xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.5 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fhirxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format FHIR XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format FHIR XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="vmrxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format vMR CDS XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format vMR CDS XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="RuleDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element">
                        <sch:assert test="not(@isMandatory='true' and @minimumMultiplicity=0)">ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:assert role="error" test="not(@isMandatory='true' and attribute[(@nullFlavor or @name='nullFlavor')][not(@prohibited='true')])"
                            >ERROR <sch:name/> defines a @nullFlavor, but element has @isMandatory='true'</sch:assert>
                        
                        <sch:assert test="not(references)">ERROR: The &lt;references/&gt; element SHALL NOT be used any more. Use rules/templateAssociation instead.</sch:assert>
                        
                        <sch:let name="ref" value="@contains"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:let name="matches" value="//rules/template[(@id|@name)=$ref]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$ref][@effectiveDate=$flexibility] | //rules/template[@ref=$ref]"/>
                        <sch:assert test="not(@contains) or ($reffedTemplate)">ERROR: <sch:name/>/@contains='<sch:value-of select="$ref"/>' SHALL point to an existing template with flexibility '<sch:value-of select="$flextext"/>'. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.</sch:assert>
                        <!--sch:assert role="warning" test="not(@contains and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][not(context)])"
                            >WARNING: <sch:name/>/@contains='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template without context. Best practise is usually to use include instead of element/@contains</sch:assert-->
                        <sch:assert role="warning" test="not(@contains and $reffedTemplate[context/@path[not(.='//')]]) or parent::choice"
                            >WARNING: <sch:name/>/@contains='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path='<sch:value-of select="$reffedTemplate/context/@path"/>'. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template</sch:assert>
                        <sch:assert role="warning" test="not(@contains) or matches(@contains,'^[0-9\.]+$')"
                            >WARNING: <sch:name/> references to a template SHOULD be based on template/@id. References by @name quickly become ambiguous</sch:assert>
                        <!--
                        <sch:assert test="not (@minimumMultiplicity and @isMandatory) or (@isMandatory='true' and @minimumMultiplicity>0)">ERROR: if isMandatory=true, minimumMultiplicity shall be
                            greater than 0</sch:assert>
                        <sch:assert test="not(@name and @include) and not(@name and @contains)">An element may contain @name or @name/@contains or @include</sch:assert>
                        -->
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])">WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.</sch:assert>-->
                        
                        <sch:let name="datatypeFile" value="if (ancestor::template/classification/@format[not(.='hl7v3xml1')]) then concat('DECOR-supported-datatypes-',ancestor::template/classification/@format[not(.='hl7v3xml1')][1],'.xml') else 'DECOR-supported-datatypes.xml'"/>
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dt" value="@datatype"/>
                        <sch:let name="dtName" value="if (contains($dt,':')) then substring-after($dt,':') else ($dt)"/>
                        <sch:assert role="error" test="not(doc-available($datatypeFile)) or not(@datatype) or doc($datatypeFile)//(dataType|flavor)[@name=($dt,$dtName)]"
                            >ERROR: the element/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype (reference file: <sch:value-of select="$datatypeFile"/>)</sch:assert>
                        
                        <sch:let name="elmpfx" value="substring-before(@name,':')"/>
                        <sch:let name="elmns" value="if ($elmpfx=('hl7','cda')) then ('urn:hl7-org:v3') else if (string-length($elmpfx)&gt;0) then (namespace-uri-for-prefix($elmpfx,/decor)) else ()"/>
                        <sch:assert role="error" test="not(@name) or $elmns"
                            >ERROR: template element/@name='<sch:value-of select="@name"/>' SHALL have a known namespace prefix ('hl7' and 'cda' are declared by default, any other SHALL be declared on the root element decor)</sch:assert>
                        
                        <sch:assert role="error" test="not(@id) or count(index-of(ancestor::template//@id,@id))=1"
                            >ERROR: template element/@id='<sch:value-of select="@id"/>' SHALL be unique within the template (version). Found <sch:value-of select="count(index-of(ancestor::template//@id,@id))"/> occurrences</sch:assert>
                        
                        <sch:let name="elmname" value="substring-after(if (contains(@name,'[')) then substring-before(@name,'[') else (@name),concat($elmpfx,':'))"/>
                        <sch:assert test="not(@name) or $elmname castable as xs:NCName"
                            >ERROR: template element/@name='<sch:value-of select="@name"/>' SHALL be a QName with (<sch:value-of select="$elmname"/>) or without predicate between brackets.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..1 inherit definitions before others in an element (indicating parent and sibling templates)
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                there may be 0..* vocabulary and 0..* property specifications
            -->
            <xs:choice>
                <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
            <!-- 
                there may be 0..* text (element content) specifications
            -->
            <xs:element name="text" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded"/>

            <!-- 
                attribute(s)
            -->
            <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                choice of
                
                let
                assert 
                report
                
                defineVariable
                
                include
                
                choice
                
                or a new nested element
                
                or (non rule generating) items
                constraint
                issue
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="name" use="optional" type="xs:anyURI"/>

        <!-- @include is no longer supported and replaced by the include element, useWhere is not implemented yet -->
        <xs:attribute name="include" type="xs:anyURI" use="prohibited"/>
        <xs:attribute name="useWhere" type="xs:boolean" default="false" use="optional"/>

        <!-- @contains -->
        <xs:attribute name="contains" type="BasicIdOrOid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>

        <!-- an optional id for to be referenced by associated concepts -->
        <xs:attribute name="id" type="Oid"/>

        <!-- data type -->
        <!--<xs:attribute name="datatype" type="DatatypeName"/>-->
        <xs:attribute name="datatype" type="xs:QName"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        
        <!-- coding strength -->
        <xs:attribute name="strength" type="CodingStrengthType" default="CNE" use="optional"/>
        
    </xs:complexType>
    <xs:complexType name="IncludeDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate includes</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//include">
                        <sch:assert test="not(@isMandatory='true' and @minimumMultiplicity=0)">ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:let name="ref" value="@ref"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:let name="matches" value="//rules/template[(@id|@name)=$ref]/xs:dateTime(@effectiveDate)"/>
                        <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max($matches))"/>
                        <sch:let name="reffedTemplate" value="//rules/template[(@id|@name)=$ref][@effectiveDate=$flexibility] | //rules/template[@ref=$ref]"/>
                        <sch:assert test="not($ref) or $reffedTemplate"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' SHALL point to an existing template with flexibility '<sch:value-of select="$flextext"/>' or a template/@ref. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.</sch:assert>
                        <sch:assert test="not($reffedTemplate/attribute) or (parent::element and not(preceding-sibling::element|preceding-sibling::choice))"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' points to a template with top level attributes, but your context is not an element</sch:assert>
                        <sch:assert role="warning" test="not(@ref and $reffedTemplate[context/@id]) or parent::choice"
                            >WARNING: <sch:name/>/@ref='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@id. Best practise is usually to use element/@contains instead of include</sch:assert>
                        <sch:assert role="warning" test="not(@ref and $reffedTemplate[context/@path[not(.='//')]])"
                            >WARNING: <sch:name/>/@ref='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path='<sch:value-of select="$reffedTemplate/context/@path"/>'. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template</sch:assert>
                        <sch:let name="tcnt" value="count($reffedTemplate/(element|choice|include))"/>
                        <sch:assert role="warning" test="not(@minimumMultiplicity|@maximumMultiplicity|@conformance|@isMandatory) or $tcnt&lt;=1"
                            >WARNING: you SHOULD NOT specify multiplicity, conformance or isMandatory on an include if it points to more than one element in the template it references.</sch:assert>
                        <sch:assert role="warning" test="not(@ref) or matches(@ref,'^[0-9\.]+$')"
                            >WARNING: <sch:name/> references to a template SHOULD be based on template/@id. References by @name quickly become ambiguous</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of an include -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="ref" type="BasicIdOrOid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="scenario" type="NonEmptyString" use="prohibited"/>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="prohibited"/>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>
    </xs:complexType>
    <xs:complexType name="InheritDefinition">
        <xs:annotation>
            <xs:appinfo>Inherit an artefact (here: a concept or a template), referenced by a ref (id). 
                If no effectiveDate is given, flexibility DYNAMIC is assumed, STATIC date otherwise.</xs:appinfo>
        </xs:annotation>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="ref" type="Oid" use="required"/>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
    </xs:complexType>
    <xs:complexType name="ChoiceDefinition">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Choice of elements and includes. The choice supports min/max occurence and any of its constituents may have a min/max occurence. Min/max on consituents cannot exceed the min/max boundaries of the choice.</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate choices</sch:title>
                    <!--<sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//choice">
                        <sch:let name="choicemin" value="@minimumMultiplicity[string-length()>0]"/>
                        <sch:let name="totalmin" value="sum((element|include|choice)[@minimumMultiplicity castable as xs:integer]/xs:integer(@minimumMultiplicity))"/>
                        
                        <sch:assert role="error" test="if ($choicemin castable as xs:integer and $totalmin) then (xs:integer($choicemin) ge $totalmin) else true()"
                            >ERROR: <sch:name/>/@minimumMultiplicity '<sch:value-of select="$choicemin"/>' SHALL be greater or equal to the sum of the @minimumMultiplicities '<sch:value-of select="$totalmin"/>' of the constituents</sch:assert>
                    </sch:rule>-->
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//choice/element | 
                                       template[not(@statusCode=('cancelled','rejected','retired'))]//choice/include | 
                                       template[not(@statusCode=('cancelled','rejected','retired'))]//choice/choice">
                        <sch:let name="choicemin" value="parent::choice/@minimumMultiplicity[string-length()>0]"/>
                        <sch:let name="choicemax" value="parent::choice/@maximumMultiplicity[string-length()>0]"/>
                        <sch:let name="childmin" value="@minimumMultiplicity[string-length()>0]"/>
                        <sch:let name="childmax" value="@minimumMultiplicity[string-length()>0]"/>
                        
                        <sch:assert role="error" test="if ($choicemin castable as xs:integer and $childmin castable as xs:integer) then (xs:integer($childmin) le xs:integer($choicemin)) else true()"
                            >ERROR: <sch:name/>/@minimumMultiplicity '<sch:value-of select="$childmin"/>' SHALL be less than or equal to the parent choice/@minimumMultiplicity '<sch:value-of select="$choicemin"/>'</sch:assert>
                        <sch:assert role="error" test="if ($choicemax castable as xs:integer and $childmax castable as xs:integer) then (xs:integer($childmax) le xs:integer($choicemax)) else if ($childmax='*') then ($choicemax='*') else true()"
                            >ERROR: <sch:name/>/@maximumMultiplicity '<sch:value-of select="$childmax"/>' SHALL be less than or equal to the parent choice/@maximumMultiplicity '<sch:value-of select="$choicemax"/>'</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
    </xs:complexType>
    <xs:element name="example">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##any" processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="type" type="ExampleType" use="optional" default="neutral">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to indicate that the instance fragment (example) is right (@type=valid) or wrong (@type=error); default is "neutral".</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Kan worden gebruikt om te markeren dat het instancefragment (voorbeeld) geldig is (@type=valid) of fout (@type=error); standaardwaarde is "neutral".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="caption" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to specify a caption (string) that precedes the instance fragment (example)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="ExampleType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of Example given</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="error">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">ongeldig</xforms:label>
                        <xforms:label xml:lang="en-US">error</xforms:label>
                        <xforms:label xml:lang="de-DE">ungültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is in error.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een foutief instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="valid">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">geldig</xforms:label>
                        <xforms:label xml:lang="en-US">valid</xforms:label>
                        <xforms:label xml:lang="de-DE">gültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is valid.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een correct instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="neutral">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">neutraal</xforms:label>
                        <xforms:label xml:lang="en-US">neutral</xforms:label>
                        <xforms:label xml:lang="de-DE">neutral</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate that the instance fragment (example) is not explictly stated to be right or wrong.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het instancefragment (voorbeeld) niet expliciet geldig of ongeldig is.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <!--
        DEPRECATED: 
    <xs:element name="references">
        < ! - - references concept="2.16.840.1.113883.2.4.6.99999.90.20010" target="2.16.840.1.113883.2.4.6.99999.90.3.700" - - >
        <xs:complexType>
            <xs:attribute name="concept" type="Oid"/>
            <xs:attribute name="target" type="Oid"/>
        </xs:complexType>
    </xs:element>
    -->
    <xs:attribute name="displayName" type="NonEmptyString">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    
    <!-- version handling -->
    <xs:attribute name="effectiveDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the effective date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expirationDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the exiration date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="officialReleaseDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the official release date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="versionLabel" type="ShortDescriptiveName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup name="VersionHandling">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="required"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="VersionHandlingEffectiveDateOptional">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes, effective date is optional here</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="optional"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:element name="let">
        <xs:complexType>
            <xs:attribute name="name" type="NonEmptyString" use="required"/>
            <xs:attribute name="value" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="assert">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="report">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defineVariable">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:element name="code" minOccurs="0" maxOccurs="1" type="VarCode"/>
                <xs:element name="use" minOccurs="0" maxOccurs="1" type="VarUse"/>
            </xs:sequence>
            <xs:attribute name="name" type="xs:NCName" use="required"/>
            <xs:attribute name="path" type="xs:anyURI" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="VarCode">
        <xs:attribute name="code" use="required" type="EnumerationString"/>
        <xs:attribute name="codeSystem" use="required" type="Oid"/>
    </xs:complexType>
    <xs:complexType name="VarUse">
        <xs:attribute name="path" use="required" type="xs:anyURI"/>
        <xs:attribute name="as" use="required" type="DatatypeName"/>
    </xs:complexType>
    <xs:simpleType name="AssertRole">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of assertion (schematron)</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="fatal"/>
            <xs:enumeration value="error"/>
            <xs:enumeration value="warning"/>
            <xs:enumeration value="hint"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="item">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:sequence>
            <xs:attribute name="label" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="context">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Template/context</sch:title>
                    <sch:rule context="template/context">
                        <sch:assert test="not(@id and @path)">ERROR: template/context SHALL have @id or @path, not both</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <!-- Was: SelfReferenceTemplateIdOrOid, but the Oid construct never made it into the template DSTU and is not currently in use or supported by DECOR2Schematron -->
            <xs:attribute name="id" use="optional" type="SelfReferenceTemplateId"/>
            <xs:attribute name="path" use="optional" type="xs:anyURI"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="SelfReferenceTemplateId">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used as the type of a context template id</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="*">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">template scope is templateId element and sibling nodes. Requires a top level element templateId with the same id as the template itself</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="**">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">template scope is top level element with templateId element and child nodes. Requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="SelfReferenceTemplateIdOrOid">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">a string "*" or "**" or a valid Oid. The value * requires a top level element templateId with the same id as the template itself. The value ** requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element. When context/@id contains an Oid, the template requires requires a top level element templateId with that same id</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="SelfReferenceTemplateId Oid"/>
    </xs:simpleType>
    <xs:element name="pathname">
        <xs:complexType>
            <xs:attribute name="path" use="required" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A real number that is restricted to a maximum of 10 characters, and may have no more than 5 decimal places.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:decimal">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
            <xs:fractionDigits value="5"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer number that is restricted to a maximum of 10 characters</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerOrDecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer or decimal range</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="IntegerRange DecimalRange"/>
    </xs:simpleType>
    <xs:element name="cardinality">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <!--
                    <sch:pattern>
                        <sch:title>Validate Cardinality</sch:title>
                        <sch:rule context="cardinality">
                            <sch:extends rule="MultiplicityRange"/>
                        </sch:rule>
                    </sch:pattern>
                    -->
                </xs:appinfo>
            </xs:annotation>
            <xs:attributeGroup ref="MultiplicityRangeRequired"/>
            <xs:attribute name="conformance" type="ConformanceType"/>
            <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="attribute">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Attribute</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//attribute">
                        <!--sch:assert role="warning" test="not(@datatype)"
                            >WARNING: The datatype SHOULD be specified on "element". Specification on "attribute" has been deprecated</sch:assert-->
                        <!--sch:assert role="error" test="@datatype = parent::element/@datatype or not(@datatype) or not(parent::element/@datatype)"
                            >ERROR: The datatype on "attribute" SHALL be equal to the datatype on "element"</sch:assert-->
                        <!--sch:assert role="warning" test="not(vocabulary)"
                            >WARNING: The vocabalary elements SHOULD be immediate children of "element". Specification as children of "attribute" has been deprecated</sch:assert-->
                        <!--<sch:assert role="error" test="not(@name or @value) or (@name and (@value or vocabulary))"
                            >ERROR: attribute MUST have both @name and (@value or vocabulary), or neither.</sch:assert>
                            -->
                        <!--
                        <sch:assert role="warning" test="not(@unit or @name='unit')">WARNING: attribute specifies @unit. This attribute SHOULD be specified through <property
                            unit="..."/></sch:assert>
                        -->
                        <sch:let name="datatypeFile" value="'DECOR-supported-datatypes.xml'"/>
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dt" value="@datatype"/>
                        <sch:let name="dtName" value="if (contains($dt,':')) then substring-after($dt,':') else ($dt)"/>
                        <sch:let name="parentDtName" value="if (contains(parent::*/@datatype,':')) then substring-after(parent::*/@datatype,':') else (parent::*/@datatype)"/>
                        <sch:let name="xsiDtName" value="if (contains(.[@name='xsi:type']/@value,':')) then substring-after(.[@name='xsi:type']/@value,':') else (.[@name='xsi:type']/@value)"/>
                        <sch:let name="dtIsFlavorAndXsiIsDatatype" value="if (doc-available($datatypeFile)) then (exists(doc($datatypeFile)//(dataType|flavor)[@name=$parentDtName]/ancestor-or-self::dataType[@name=$xsiDtName])) else (true())"/>
                        
                        <sch:assert role="warning" test="not($parentDtName and $xsiDtName) or $dtIsFlavorAndXsiIsDatatype"
                            >WARNING: attribute @xsi:type SHOULD NOT specify a value '<sch:value-of select="$xsiDtName"/>', or SHOULD specify a value that matches the element definition '<sch:value-of select="$parentDtName"/>', or SHOULD specify a value that matches the base datatype when the element definition specifies a flavor</sch:assert>
                        <sch:assert role="warning" test="not(@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)"
                            >WARNING: Shorthand for HL7 V3 attribute found. Use is discouraged, please use @name='..' and optionally @value='..' instead</sch:assert>
                        <sch:assert role="error" test="not((@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)[contains(.,'|')])"
                            >ERROR: this attribute cannot define a choice for its value. Please use @name.</sch:assert>
                        <sch:assert role="error" test="not(count(@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)>1 and @id)"
                            >ERROR: attribute with multiple shorthands SHALL NOT have @id as that would be ambiguous.</sch:assert>
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])"
                            >WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.</sch:assert>-->
                        
                        <sch:assert role="error" test="not(doc-available($datatypeFile)) or not(@datatype) or doc($datatypeFile)//(atomicDataType|flavor)[@name=($dt,$dtName)]"
                            >ERROR: the attribute/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype (reference file: <sch:value-of select="$datatypeFile"/>)</sch:assert>
                        
                        <sch:assert role="error" test="not(contains(@value,'|'))"
                            >ERROR: the attribute/@name='<sch:value-of select="@name"/>' SHOULD NOT have a choice as its @value ('<sch:value-of select="@value"/>'). The schematron engine will NOT support that and treat it as a literal string.</sch:assert>
                        
                        <sch:assert role="error" test="true()=(
                            for $att in (@name, (@classCode|@contextConductionInd|@contextControlCode|@determinerCode|@extension|@independentInd|@institutionSpecified|@inversionInd|@mediaType|@moodCode|@negationInd|@nullFlavor|@operator|@qualifier|@representation|@root|@typeCode|@unit|@use)/name()) 
                                return count(../attribute[@name=$att or @*[not(name()=('name','value','isOptional','prohibited','datatype','id'))]/name()=$att])=1)"
                            >ERROR: an attribute SHALL NOT be defined more than once on the same element</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- item label, inherited by all subsequent elements unless overridden -->
                <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
                
                <xs:choice>
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                </xs:choice>
                
                <!-- constraints for attributes of type "coded" or "quantities"??????? -->
                <!-- 
                    <xs:choice maxOccurs="1">
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="property" minOccurs="0" maxOccurs="1"/>
                </xs:choice>
                -->
            </xs:sequence>
            
            <!-- == start definitional attributes -->
            <!-- name of attributes required (name) -->
            <xs:attribute name="name" type="EnumerationToken"/>
            
            <!-- data type II: elements where other siblings are allowed -->
            <xs:attribute name="value" type="NonEmptyString"/>
            <!-- == end definitional attributes -->
            
            <!-- == start shorthand attributes (discouraged) == -->
            <!-- (@classCode|@contextConductionInd|@contextControlCode|@determinerCode|
                  @extension|@independentInd|@institutionSpecified|@inversionInd|
                  @mediaType|@moodCode|@negationInd|@nullFlavor|
                  @operator|@qualifier|@representation|@root|
                  @typeCode|@unit|@use) -->
            <xs:attribute name="classCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="contextConductionInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="contextControlCode" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="determinerCode" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="extension" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="independentInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="institutionSpecified" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="inversionInd" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mediaType" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="moodCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="negationInd" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="nullFlavor" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="operator" type="EnumerationToken">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="qualifier" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="representation" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="root" type="OidChoiceList">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="typeCode" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="unit" type="NonEmptyString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="use" type="EnumerationString">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Shorthand for HL7 V3 attribute. Use is discouraged, please use @name='..' and optionally @value='..' instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- == end shorthand attributes (discouraged) == -->
            
            <!-- == start attribute properties == -->
            
            <xs:attribute name="isOptional" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is requird to be in the instance. Default is 'false', meaning that the attribute is NOT optional, and thus required.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="prohibited" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is prohibited to be in the instance.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <!--<xs:attribute name="datatype" type="AttributeDatatypeName"/>-->
            <xs:attribute name="datatype" type="xs:QName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines the datatype of the attribute in the instance.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- == end attributes properties == -->
            
            <!-- == start DECOR internal purpose only == -->
            <!-- 20141215 - an optional id for to be referenced by associated concepts -->
            <xs:attribute name="id" type="Oid"/>
            <!-- == end DECOR internal purpose only == -->
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="AttributeDatatypeName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used for datatype names of attributes only</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:maxLength value="60"/>
            <xs:pattern value="[a-z_]+(.[a-z]+)*(.diffType)?"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="property">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Property</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/property">
                        <sch:assert role="error" test="count(@* except (@unit|@minInclude|@maxInclude|@fractionDigits))=0 or count(@* except (@currency|@minInclude|@maxInclude|@fractionDigits))=0 or count(@* except (@minLength|@maxLength))=0 or count(@* except (@value))=0">ERROR: property contains illegal combination of attributes.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of type "quantity", "string" or "boolean". Allows assertion of one or more units, ranges, fraction digits or fixed values. Valid
                combinations of attributes are: <li>
                    <ul>@unit @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@currency @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@minLength @maxLength</ul>
                    <ul>@value</ul>
                </li>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>

            <!-- quantity constraints -->
            <xs:attribute name="unit" type="NonEmptyString"/>
            <xs:attribute name="currency" type="NonEmptyString"/>
            <xs:attribute name="minInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="maxInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="fractionDigits" type="FractionDigitsType"/>

            <!-- string constraints -->
            <xs:attribute name="minLength" type="SmallNonNegativeInteger"/>
            <xs:attribute name="maxLength" type="SmallNonNegativeInteger"/>

            <!-- fixed values -->
            <xs:attribute name="value" type="NonEmptyString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="FractionDigitsType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="\d{1,4}[!]{0,1}"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="vocabulary">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Attribute Vocabulary</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//attribute/vocabulary">
                        <sch:assert role="error" test="count(@* except (@valueSet|@flexibility|@code))=0"
                            >ERROR: <sch:name path=".."/>/<sch:name/> SHALL NOT have other attributes than @valueSet, @flexibility or @code.</sch:assert>
                        <sch:assert test="not(@valueSet) or count(@* except (@valueSet|@flexibility))=0"
                            >ERROR: <sch:name path=".."/>/<sch:name/>/@valueSet SHALL NOT co-occur with any other attribute than @flexibility</sch:assert>
                        <sch:assert test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: <sch:name/>/@domain SHALL NOT co-occur with any other attribute</sch:assert>
                        
                        <sch:assert test="not(@valueSet) or @valueSet=//terminology/valueSet/(@ref|@id|@name)"
                            >ERROR: <sch:name/>/@valueSet="<sch:value-of select="@valueSet"/>" SHOULD have a matching terminology/valueSet. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.</sch:assert>
                        <sch:assert role="warning" test="not(@valueSet) or matches(@valueSet,'^[0-9\.]+$')"
                            >ERROR: <sch:name/> references to a value set SHOULD be based on valueSet/@id. References by @name quickly become ambiguous</sch:assert>
                    </sch:rule>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/vocabulary">
                        <sch:assert test="not(@valueSet) or count(@* except (@valueSet|@flexibility))=0"
                            >ERROR: <sch:name/>/@valueSet SHALL NOT co-occur with any other attribute than @flexibility</sch:assert>
                        <sch:assert test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: <sch:name/>/@domain SHALL NOT co-occur with any other attribute</sch:assert>
                        
                        <sch:let name="vsref" value="@valueSet"/>
                        <sch:let name="vsflex" value="if (matches(@flexibility,'^\d{4}')) then @flexibility else (string(max(//terminology/valueSet[(@name|@id|@ref)=$vsref][@effectiveDate]/xs:dateTime(@effectiveDate))))"/>
                        <sch:let name="vsflextext" value="if (matches(@flexibility,'^\d{4}')) then @flexibility else ('dynamic')"/>
                        <sch:let name="vs" value="//terminology/valueSet[(@name|@id|@ref)=$vsref][not(@effectiveDate) or @effectiveDate=$vsflex]"/>
                        
                        <sch:assert test="not(@valueSet) or @valueSet=//terminology/valueSet/(@ref|@id|@name)"
                            >ERROR: <sch:name/>/@valueSet="<sch:value-of select="@valueSet"/>" SHALL have a matching terminology/valueSet. Note that in the pre-publication compile phase these references will be resolved if possible, regardless of a reference, but they will not be in your list of artifacts in ART while there is no reference.</sch:assert>
                        <sch:assert role="warning" test=" not(@valueSet) or not($vs[@id]/conceptList/(exception|insert[@exception='true']) and parent::element[@isMandatory='true'])"
                            >WARNING: <sch:name/>/@valueSet '<sch:value-of select="$vsref"/>' (<sch:value-of select="$vsflextext"/>) contains exceptions, but element has @isMandatory='true'. This renders those exceptions invalid in this context.</sch:assert>
                        <!-- cannot check valueSet/@ref so make exception for that situation... -->
                        <sch:assert role="warning" test="not(@valueSet) or $vs[@id]/conceptList/(exception|insert[@exception='true']) or parent::element[@isMandatory='true'] or not(parent::element[number(@minimumMultiplicity)>0][@conformance='R']) or $vs[@ref]"
                            >WARNING: <sch:name/>/@valueSet '<sch:value-of select="$vsref"/>' (<sch:value-of select="$vsflextext"/>) does not contain exceptions, but element has @conformance 'required' and @minimumMultiplicity > 0. This effectively places all nullFlavors in scope, making it harder to implement</sch:assert>
                        <sch:assert role="warning" test="not(@valueSet) or matches(@valueSet,'^[0-9\.]+$')"
                            >ERROR: <sch:name/> references to a template SHOULD be based on template/@id. References by @name quickly become ambiguous</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of "coded" types. Allows assertion of one or more codes, code systems or value sets.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <!-- value set assertions -->
            <xs:attribute name="valueSet" type="BasicIdOrOid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id or @name. References to @name are discouraged because they become ambiguous quickly.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility" use="optional" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- code constraints -->
            <xs:attribute name="code" type="EnumerationString" use="optional"/>
            <xs:attribute name="codeSystem" type="Oid" use="optional"/>

            <!-- other constraints -->
            <xs:attribute ref="displayName" use="optional"/>
            <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional"/>
            
            <!-- concept domain (a sinple string as an "abstract" indication only) -->
            <xs:attribute name="domain" type="NonEmptyString" use="optional"/>
            
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="CodingStrengthType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Coding strength of a vocabulary binding</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="CNE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gecodeerd zonder uitzonderingen</xforms:label>
                        <xforms:label xml:lang="en-US">Coded with no Exceptions</xforms:label>
                        <xforms:label xml:lang="de-DE">Coded with no Exceptions</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CWE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gecodeerd met uitzonderingen</xforms:label>
                        <xforms:label xml:lang="en-US">Coded with Exceptions</xforms:label>
                        <xforms:label xml:lang="de-DE">Coded with Exceptions</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- =================================== -->
    
    <!-- =================================== -->
    <!-- COMPILATION ADDED STUFF -->
    <!-- versionDate="2015-03-18T11:10:06" versionLabel="" compilationDate="2015-03-18T11:10:06" language="nl-NL" deeplinkprefix="http://localhost:8080/art-decor/" deeplinkprefixservices="http://localhost:8877/decor/services/" -->
    <xs:attributeGroup name="DecorCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the decor root element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="versionDate" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the date stamp or 'development' for the currently processed project/(version|release)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="versionLabel" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the label for the currently processed project/(version|release)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="compilationDate" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the date stamp or 'development' of the compilation process</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="language" type="xs:language" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains principal used in the compilation process (compilation may be run multiple times, one per language)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deeplinkprefix" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains ART-DECOR URI of the server that ran the compilation.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deeplinkprefixservices" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains DECOR services URI of the server that ran the compilation.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="DatasetCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the dataset element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="shortName" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the short name for the dataset</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="DatasetConceptCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the dataset element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="iddisplay" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the calculated display name for the value in @id</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="refdisplay" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the calculated display name for the value in @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortName" type="xs:string" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the short name for the concept</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:group name="DatasetConceptCompilationImplementation">
        <xs:sequence>
            <xs:element name="implementation" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the implementation specific info (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="DatasetConceptCompilationTerminologyAssociation">
        <xs:sequence>
            <xs:element ref="terminologyAssociation" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the copied terminology association from the terminology section applicable for this concept (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="DatasetConceptCompilationValueSet">
        <xs:sequence>
            <xs:element name="valueSet" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the enahanced value set bound to this concept (TODO: explain in more detail)</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="ValueSetCompilationSourceCodeSystem">
        <xs:sequence>
            <xs:element name="sourceCodeSystem" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains display names for code systems as an optimalization aid in the publication process</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:any processContents="skip" namespace="##any" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:anyAttribute processContents="skip" namespace="##any"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="ValueSetCompilationAttributes">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Additional compilation attributes on the value set element</xs:documentation>
        </xs:annotation>
        <xs:attribute name="url" type="xs:anyURI" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the services URL useful in retrieving the value set</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ident" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the project @prefix of the project that defines the value set</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="referencedFrom" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Added in compilation process for releases. DO NOT ADD/EDIT yourself. Contains the project @prefix of the project that referenced the value set (normally current project)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="TemplateCompilationAttributes">
        <xs:attributeGroup ref="ValueSetCompilationAttributes"/>
    </xs:attributeGroup>
    <!-- =================================== -->
</xs:schema>